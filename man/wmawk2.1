.SH NAME
.PP
Wmawk2 - pattern scanning and text processing language
.SH SYNOPSIS
.PP
\f[B]Wmawk2\f[R] [-\f[B]W\f[R] \f[I]option\f[R]] [-\f[B]F\f[R]
\f[I]value\f[R]] [-\f[B]v\f[R] \f[I]var=value\f[R]] [-\[u2006]-]
\[aq]program text\[aq] [file ...]
.PD 0
.P
.PD
\f[B]Wmawk2\f[R] [-\f[B]W\f[R] \f[I]option\f[R]] [-\f[B]F\f[R]
\f[I]value\f[R]] [-\f[B]v\f[R] \f[I]var=value\f[R]] [-\f[B]f\f[R]
\f[I]program-file\f[R]] [-\[u2006]-] [file ...]
.SH DESCRIPTION
.PP
\f[B]Wmawk2\f[R] is an interpreter for the AWK Programming Language.
The AWK language is useful for manipulation of data files, text
retrieval and processing, and for prototyping and experimenting with
algorithms.
\f[B]Wmawk2\f[R] is a \f[I]new awk\f[R] meaning it implements the AWK
language as defined in Aho, Kernighan and Weinberger, \f[I]The AWK
Programming Language,\f[R] Addison-Wesley Publishing, 1988.
(Hereafter referred to as the AWK book.) \f[B]Wmawk2\f[R] conforms to
the Posix 1003.2 (draft 11.3) definition of the AWK language which
contains a few features not described in the AWK book, and
\f[B]Wmawk2\f[R] provides a small number of extensions.
.PP
\f[B]Wmawk2\f[R] a port of mawk 1.9.9.6 to Windows.
It was created because the version of on github (
https://github.com/mikebrennan000/mawk-2 ) did not compile for Windows
when using tdm-gcc 9.2.2, and when these issues were resolved the system
command did not work.
The systime() function was also added.
.PP
An AWK program is a sequence of \f[I]pattern {action}\f[R] pairs and
function definitions.
Short programs are entered on the command line usually enclosed in \[aq]
\[aq] to avoid shell interpretation.
Longer programs can be read in from a file with the -f option.
Data input is read from the list of files on the command line or from
standard input when the list is empty.
The input is broken into records as determined by the record separator
variable, \f[B]RS\f[R].
Initially, \f[B]RS\f[R] = \[dq]\[rs]n\[dq] and records are synonymous
with lines.
Each record is compared against each \f[I]pattern\f[R] and if it
matches, the program text for \f[I]{action}\f[R] is executed.
.SH OPTIONS
.TP
-F \f[I]value\f[R]
sets the field separator, \f[B]FS\f[R], to \f[I]value\f[R].
.TP
-f \f[I]file\f[R]
Program text is read from \f[I]file\f[R] instead of from the command
line.
Multiple \f[B]-f\f[R] options are allowed.
.TP
-v \f[I]var=value\f[R]
assigns \f[I]value\f[R] to program variable \f[I]var\f[R].
.TP
-\[u2006]-
indicates the unambiguous end of options.
.PP
The above options will be available with any Posix compatible
implementation of AWK, and implementation specific options are prefaced
with \f[B]-W\f[R].
\f[B]Wmawk2\f[R] provides six:
.TP
-W version
\f[B]Wmawk2\f[R] writes its version and copyright to stdout and compiled
limits to stderr and exits 0.
.TP
-W dump
writes an assembler like listing of the internal representation of the
program to stdout and exits 0 (on successful compilation).
.TP
-W interactive
sets unbuffered writes to stdout and line buffered reads from stdin.
Records from stdin are lines regardless of the value of \f[B]RS\f[R].
.TP
-W exec \f[I]file\f[R]
Program text is read from \f[I]file\f[R] and this is the last option.
Useful on systems that support the \f[B]#!\f[R] \[dq]magic number\[dq]
convention for executable scripts.
.TP
-W sprintf=\f[I]num\f[R]
adjusts the size of \f[B]Wmawk2\[aq]s\f[R] internal sprintf buffer to
\f[I]num\f[R] bytes.
More than rare use of this option indicates \f[B]Wmawk2\f[R] should be
recompiled.
.TP
-W posix_space
forces \f[B]Wmawk2\f[R] not to consider \[aq]\[rs]n\[aq] to be space.
.PP
The short forms \f[B]-W\f[R][vdiesp] are recognized and on some systems
\f[B]-W\f[R]e is mandatory to avoid command line length limitations.
.SH THE AWK LANGUAGE
.SS 1. Program structure
.PP
An AWK program is a sequence of \f[I]pattern {action}\f[R] pairs and
user function definitions.
.PP
A pattern can be:
.IP
.nf
\f[C]
BEGIN
END
expression
expression , expression
\f[R]
.fi
.PP
One, but not both, of \f[I]pattern {action}\f[R] can be omitted.
If \f[I]{action}\f[R] is omitted it is implicitly { print }.
If \f[I]pattern\f[R] is omitted, then it is implicitly matched.
\f[B]BEGIN\f[R] and \f[B]END\f[R] patterns require an action.
.PP
Statements are terminated by newlines, semi-colons or both.
Groups of statements such as actions or loop bodies are blocked via {
\&...
} as in C.
The last statement in a block doesn\[aq]t need a terminator.
Blank lines have no meaning; an empty statement is terminated with a
semi-colon.
Long statements can be continued with a backslash, \[rs]\[u2006].
A statement can be broken without a backslash after a comma, left brace,
&&, ||, \f[B]do\f[R], \f[B]else\f[R], the right parenthesis of an
\f[B]if\f[R], \f[B]while\f[R] or \f[B]for\f[R] statement, and the right
parenthesis of a function definition.
A comment starts with # and extends to, but does not include the end of
line.
.PP
The following statements control program flow inside blocks.
.RS
.PP
\f[B]if\f[R] ( \f[I]expr\f[R] ) \f[I]statement\f[R]
.PP
\f[B]if\f[R] ( \f[I]expr\f[R] ) \f[I]statement\f[R] \f[B]else\f[R]
\f[I]statement\f[R]
.PP
\f[B]while\f[R] ( \f[I]expr\f[R] ) \f[I]statement\f[R]
.PP
\f[B]do\f[R] \f[I]statement\f[R] \f[B]while\f[R] ( \f[I]expr\f[R] )
.PP
\f[B]for\f[R] ( \f[I]opt_expr\f[R] ; \f[I]opt_expr\f[R] ;
\f[I]opt_expr\f[R] ) \f[I]statement\f[R]
.PP
\f[B]for\f[R] ( \f[I]var\f[R] \f[B]in\f[R] \f[I]array\f[R] )
\f[I]statement\f[R]
.PP
\f[B]continue\f[R]
.PP
\f[B]break\f[R]
.RE
.SS 2. Data types, conversion and comparison
.PP
There are two basic data types, numeric and string.
Numeric constants can be integer like -2, decimal like 1.08, or in
scientific notation like -1.1e4 or .28E-3.
All numbers are represented internally and all computations are done in
floating point arithmetic.
So, for example, the expression 0.2e2 == 20 is true and true is
represented as 1.0.
.PP
String constants are enclosed in double quotes.
.PP
\[dq]This is a string with a newline at the end.\[rs]n\[dq]
.PP
Strings can be continued across a line by escaping (\[rs]) the newline.
The following escape sequences are recognized.
.IP
.nf
\f[C]
	\[rs]\[rs]		\[rs]
	\[rs]\[dq]		\[dq]
	\[rs]a		alert, ascii 7
	\[rs]b		backspace, ascii 8
	\[rs]t		tab, ascii 9
	\[rs]n		newline, ascii 10
	\[rs]v		vertical tab, ascii 11
	\[rs]f		formfeed, ascii 12
	\[rs]r		carriage return, ascii 13
	\[rs]ddd		1, 2 or 3 octal digits for ascii ddd
	\[rs]xhh		1 or 2 hex digits for ascii  hh
\f[R]
.fi
.PP
If you escape any other character \[rs]c, you get \[rs]c, i.e.,
\f[B]Wmawk2\f[R] ignores the escape.
.PP
Note that in replacement strings \[rs] escapes \[rs] and \[rs] escapes
&, but only if the run of \[rs] ends in & so that the script
{sub(/B/,\[dq]\[rs]\[rs]\[rs]\[rs]\[dq]) ; print} fed with the input ABC
will give A\[rs]\[rs]C
.PP
There are really three basic data types; the third is \f[I]number and
string\f[R] which has both a numeric value and a string value at the
same time.
User defined variables come into existence when first referenced and are
initialized to \f[I]null\f[R], a number and string value which has
numeric value 0 and string value \[dq]\[dq].
Non-trivial number and string typed data come from input and are
typically stored in fields.
(See section 4).
.PP
The type of an expression is determined by its context and automatic
type conversion occurs if needed.
For example, to evaluate the statements
.IP
.nf
\f[C]
	y = x + 2  ;  z = x  \[dq]hello\[dq]
\f[R]
.fi
.PP
The value stored in variable y will be typed numeric.
If x is not numeric, the value read from x is converted to numeric
before it is added to 2 and stored in y.
The value stored in variable z will be typed string, and the value of x
will be converted to string if necessary and concatenated with
\[dq]hello\[dq].
(Of course, the value and type stored in x is not changed by any
conversions.) A string expression is converted to numeric using its
longest numeric prefix as with \f[I]atof\f[R](3).
A numeric expression is converted to string by replacing \f[I]expr\f[R]
with \f[B]sprintf(CONVFMT\f[R], \f[I]expr\f[R]), unless \f[I]expr\f[R]
can be represented on the host machine as an exact integer then it is
converted to \f[B]sprintf\f[R](\[dq]%d\[dq], \f[I]expr\f[R]).
\f[B]Sprintf()\f[R] is an AWK built-in that duplicates the functionality
of \f[I]sprintf\f[R](3), and \f[B]CONVFMT\f[R] is a built-in variable
used for internal conversion from number to string and initialized to
\[dq]%.6g\[dq].
Explicit type conversions can be forced, \f[I]expr\f[R] \[dq]\[dq] is
string and \f[I]expr\f[R]+0 is numeric.
.PP
To evaluate, \f[I]expr\f[R]1 \f[B]rel-op\f[R] \f[I]expr\f[R]2, if both
operands are numeric or number and string then the comparison is
numeric; if both operands are string the comparison is string; if one
operand is string, the non-string operand is converted and the
comparison is string.
The result is numeric, 1 or 0.
.PP
In boolean contexts such as, \f[B]if\f[R] ( \f[I]expr\f[R] )
\f[I]statement\f[R], a string expression evaluates true if and only if
it is not the empty string \[dq]\[dq]; numeric values if and only if not
numerically zero.
.SS 3. Regular expressions
.PP
In the AWK language, records, fields and strings are often tested for
matching a \f[I]regular expression\f[R].
Regular expressions are enclosed in slashes, and
.IP
.nf
\f[C]
	expr \[ti] /r/
\f[R]
.fi
.PP
is an AWK expression that evaluates to 1 if \f[I]expr\f[R]
\[dq]matches\[dq] \f[I]r\f[R], which means a substring of \f[I]expr\f[R]
is in the set of strings defined by \f[I]r\f[R].
With no match the expression evaluates to 0; replacing \[ti] with the
\[dq]not match\[dq] operator, !\[ti] , reverses the meaning.
As pattern-action pairs,
.IP
.nf
\f[C]
	/r/ { action }   and   $0 \[ti] /r/ { action }
\f[R]
.fi
.PP
are the same, and for each input record that matches \f[I]r\f[R],
\f[I]action\f[R] is executed.
In fact, /\f[I]r\f[R]/ is an AWK expression that is equivalent to
(\f[B]$0\f[R] \[ti] /\f[I]r\f[R]/) anywhere except when on the right
side of a match operator or passed as an argument to a built-in function
that expects a regular expression argument.
.PP
AWK uses extended regular expressions as with \f[I]egrep\f[R](1).
The regular expression metacharacters, i.e., those with special meaning
in regular expressions are
.IP
.nf
\f[C]
	 \[ha] $ . [ ] | ( ) * + ?
\f[R]
.fi
.PP
Regular expressions are built up from characters as follows:
.TP
\f[I]c\f[R]
matches any non-metacharacter \f[I]c\f[R].
.TP
\[rs]\f[I]c\f[R]
matches a character defined by the same escape sequences used in string
constants or the literal character \f[I]c\f[R] if \[rs]\f[I]c\f[R] is
not an escape sequence.
.TP
\&.
matches any character (including newline).
.TP
\[ha]
matches the front of a string.
.TP
$
matches the back of a string.
.TP
[c1c2c3...]
matches any character in the class c1c2c3...
\&.
An interval of characters is denoted c1-c2 inside a class [...].
.TP
[\[ha]c1c2c3...]
matches any character not in the class c1c2c3...
.RS
.PP
Character classes are also support, these can only be used inside the
brackets of a regular expression and define groups of characters in a
portable manner (e.g., /[[:digit:]]/ ).
The list that are supported by Wmawk2 is: alnum, alpha, blank, cntrl,
digit, graph, lower, print, space, upper, xdigit.
These are defined as:
.RE
\[bu] .RS 2
.PP
alnum \[en] alphanumeric characters (typically a-z A-Z 0-9)
.RE
\[bu] .RS 2
.PP
alpha \[en] alphabetic characters (typically a-z A-Z)
.RE
\[bu] .RS 2
.PP
blank \[en] space and tab characters
.RE
\[bu] .RS 2
.PP
cntrl \[en] control characters
.RE
\[bu] .RS 2
.PP
digit \[en] typically 0-9
.RE
\[bu] .RS 2
.PP
graph \[en] characters that are both printable and visible (e.g., a
space is not visible)
.RE
\[bu] .RS 2
.PP
lower \[en] lower case alphabetic characters (typically a-z)
.RE
\[bu] .RS 2
.PP
print \[en] printable characters (characters that are not control
characters)
.RE
\[bu] .RS 2
.PP
space \[en] typically space, tab, newline, carriage return, formfeed and
vertical tab.
.RE
\[bu] .RS 2
.PP
Upper - upper case alphabetic characters (typically A-Z)
.RE
\[bu] .RS 2
.PP
Xdigit \[en] hex digits (typically 0-9 a-f A-F)
.RE
.PP
Regular expressions are built up from other regular expressions as
follows:
.TP
\f[I]r\f[R]1\f[I]r\f[R]2
matches \f[I]r\f[R]1 followed immediately by \f[I]r\f[R]2
(concatenation).
.TP
\f[I]r\f[R]1 | \f[I]r\f[R]2
matches \f[I]r\f[R]1 or \f[I]r\f[R]2 (alternation).
.TP
\f[I]r\f[R]*
matches \f[I]r\f[R] repeated zero or more times.
.TP
\f[I]r\f[R]+
matches \f[I]r\f[R] repeated one or more times.
.TP
\f[I]r\f[R]?
matches \f[I]r\f[R] zero or once.
.TP
(\f[I]r\f[R])
matches \f[I]r\f[R], providing grouping.
.PP
The increasing precedence of operators is alternation, concatenation and
unary (*, + or ?).
.PP
For example,
.IP
.nf
\f[C]
	/\[ha][_a-zA-Z][_a-zA-Z0-9]*$/  and
	/\[ha][-+]?([0-9]+\[rs]\[u2006].?|\[rs]\[u2006].[0-9])[0-9]*([eE][-+]?[0-9]+)?$/
\f[R]
.fi
.PP
are matched by AWK identifiers and AWK numeric constants respectively.
Note that .
has to be escaped to be recognized as a decimal point, and that
metacharacters are not special inside character classes.
.PP
Any expression can be used on the right hand side of the \[ti] or !\[ti]
operators or passed to a built-in that expects a regular expression.
If needed, it is converted to string, and then interpreted as a regular
expression.
For example,
.IP
.nf
\f[C]
	BEGIN { identifier = \[dq][_a-zA-Z][_a-zA-Z0-9]*\[dq] }

	$0 \[ti] \[dq]\[ha]\[dq] identifier
\f[R]
.fi
.PP
prints all lines that start with an AWK identifier.
.PP
\f[B]Wmawk2\f[R] recognizes the empty regular expression, //\[u2006],
which matches the empty string and hence is matched by any string at the
front, back and between every character.
For example,
.IP
.nf
\f[C]
	echo  abc | Wmawk2 { gsub(//, \[dq]X\[dq]) ; print }
	XaXbXcX
\f[R]
.fi
.SS 4. Records and fields
.PP
Records are read in one at a time, and stored in the \f[I]field\f[R]
variable \f[B]$0\f[R].
The record is split into \f[I]fields\f[R] which are stored in
\f[B]$1\f[R], \f[B]$2\f[R], ..., \f[B]$NF\f[R].
The built-in variable \f[B]NF\f[R] is set to the number of fields, and
\f[B]NR\f[R] and \f[B]FNR\f[R] are incremented by 1.
Fields above \f[B]$NF\f[R] are set to \[dq]\[dq].
.PP
Assignment to \f[B]$0\f[R] causes the fields and \f[B]NF\f[R] to be
recomputed.
Assignment to \f[B]NF\f[R] or to a field causes \f[B]$0\f[R] to be
reconstructed by concatenating the \f[B]$i\[aq]s\f[R] separated by
\f[B]OFS\f[R].
Assignment to a field with index greater than \f[B]NF\f[R], increases
\f[B]NF\f[R] and causes \f[B]$0\f[R] to be reconstructed.
.PP
Data input stored in fields is string, unless the entire field has
numeric form and then the type is number and string.
For example,
.IP
.nf
\f[C]
	echo 24 24E | 
	Wmawk2 \[aq]{ print($1>100, $1>\[dq]100\[dq], $2>100, $2>\[dq]100\[dq]) }\[aq]
	0 1 1 1
\f[R]
.fi
.PP
\f[B]$0\f[R] and \f[B]$2\f[R] are string and \f[B]$1\f[R] is number and
string.
The first comparison is numeric, the second is string, the third is
string (100 is converted to \[dq]100\[dq]), and the last is string.
.SS 5. Expressions and operators
.PP
The expression syntax is similar to C.
Primary expressions are numeric constants, string constants, variables,
fields, arrays and function calls.
The identifier for a variable, array or function can be a sequence of
letters, digits and underscores, that does not start with a digit.
Variables are not declared; they exist when first referenced and are
initialized to \f[I]null\f[R].
.PP
New expressions are composed with the following operators in order of
increasing precedence.
.IP
.nf
\f[C]
assignment		=  +=  -=  *=  /=  %=  \[ha]=
conditional		?  :
logical or		||
logical and		&&
array membership	in
matching		\[ti]   !\[ti]
relational		<  >   <=  >=  ==  !=
concatenation	(no explicit operator)
add ops		+  -
mul ops		*  /  % 
unary			+  -
logical not		!
exponentiation	\[ha]
inc and dec		++ -\[u2006]- (both post and pre)
field			$
\f[R]
.fi
.RS
.PP
Assignment, conditional and exponentiation associate right to left; the
other operators associate left to right.
Any expression can be parenthesized.
.RE
.SS 6. Arrays
.PP
Awk provides one-dimensional arrays.
Array elements are expressed as \f[I]array\f[R][\f[I]expr\f[R]].
\f[I]Expr\f[R] is internally converted to string type, so, for example,
A[1] and A[\[dq]1\[dq]] are the same element and the actual index is
\[dq]1\[dq].
Arrays indexed by strings are called associative arrays.
Initially an array is empty; elements exist when first accessed.
An expression, \f[I]expr\f[R] \f[B]in\f[R] \f[I]array\f[R] evaluates to
1 if \f[I]array\f[R][\f[I]expr\f[R]] exists, else to 0.
.PP
There is a form of the \f[B]for\f[R] statement that loops over each
index of an array.
.IP
.nf
\f[C]
	for ( var in array ) statement
\f[R]
.fi
.PP
sets \f[I]var\f[R] to each index of \f[I]array\f[R] and executes
\f[I]statement\f[R].
The order that \f[I]var\f[R] transverses the indices of \f[I]array\f[R]
is not defined.
.PP
The statement, \f[B]delete\f[R] \f[I]array\f[R][\f[I]expr\f[R]], causes
\f[I]array\f[R][\f[I]expr\f[R]] not to exist.
\f[B]Wmawk2\f[R] supports an extension, \f[B]delete\f[R]
\f[I]array\f[R], which deletes all elements of \f[I]array\f[R].
.PP
Multidimensional arrays are synthesized with concatenation using the
built-in variable \f[B]SUBSEP\f[R].
\f[I]array\f[R][\f[I]expr\f[R]1,\[u2006]\f[I]expr\f[R]2] is equivalent
to \f[I]array\f[R][\f[I]expr\f[R]1 \f[B]SUBSEP\f[R] \f[I]expr\f[R]2].
Testing for a multidimensional element uses a parenthesized index, such
as
.IP
.nf
\f[C]
	if ( (i, j) in A )  print A[i, j]
\f[R]
.fi
.SS 7. Builtin-variables
.PP
The following variables are built-in and initialized before program
execution.
.TP
ARGC
number of command line arguments.
.TP
ARGV
array of command line arguments, 0..ARGC-1.
.TP
CONVFMT
format for internal conversion of numbers to string, initially =
\[dq]%.6g\[dq].
.TP
ENVIRON
array indexed by environment variables.
An environment string, \f[I]var=value\f[R] is stored as
\f[B]ENVIRON\f[R][\f[I]var\f[R]] = \f[I]value\f[R].
.TP
FILENAME
name of the current input file.
.TP
FNR
current record number in \f[B]FILENAME\f[R].
.TP
FS
splits records into fields as a regular expression.
.TP
NF
number of fields in the current record.
.TP
NR
current record number in the total input stream.
.TP
OFMT
format for printing numbers; initially = \[dq]%.6g\[dq].
.TP
OFS
inserted between fields on output, initially = \[dq] \[dq].
.TP
ORS
terminates each record on output, initially = \[dq]\[rs]n\[dq].
.TP
RLENGTH
length set by the last call to the built-in function, \f[B]match()\f[R].
.TP
RS
input record separator, initially = \[dq]\[rs]n\[dq].
.TP
RSTART
index set by the last call to \f[B]match()\f[R].
.TP
SUBSEP
used to build multiple array subscripts, initially = \[dq]\[rs]034\[dq].
.SS 8. Built-in functions
.SS String functions
.TP
gsub(\f[I]r,s,t\f[R]) gsub(\f[I]r,s\f[R])
Global substitution, every match of regular expression \f[I]r\f[R] in
variable \f[I]t\f[R] is replaced by string \f[I]s\f[R].
The number of replacements is returned.
If \f[I]t\f[R] is omitted, \f[B]$0\f[R] is used.
An & in the replacement string \f[I]s\f[R] is replaced by the matched
substring of \f[I]t\f[R].
\[rs]& and \[rs]\[rs] put literal & and \[rs], respectively, in the
replacement string.
.TP
index(\f[I]s,t\f[R])
If \f[I]t\f[R] is a substring of \f[I]s\f[R], then the position where
\f[I]t\f[R] starts is returned, else 0 is returned.
The first character of \f[I]s\f[R] is in position 1.
.TP
length(\f[I]s\f[R])
Returns the length of string \f[I]s\f[R].
.RS
.PP
If s is an array length returns the number of elements in the array.
.RE
.TP
match(\f[I]s,r\f[R])
Returns the index of the first longest match of regular expression
\f[I]r\f[R] in string \f[I]s\f[R].
Returns 0 if no match.
As a side effect, \f[B]RSTART\f[R] is set to the return value.
\f[B]RLENGTH\f[R] is set to the length of the match or -1 if no match.
If the empty string is matched, \f[B]RLENGTH\f[R] is set to 0, and 1 is
returned if the match is at the front, and length(\f[I]s\f[R])+1 is
returned if the match is at the back.
.TP
split(\f[I]s,A,r\f[R]) split(\f[I]s,A\f[R])
String \f[I]s\f[R] is split into fields by regular expression
\f[I]r\f[R] and the fields are loaded into array \f[I]A\f[R].
The number of fields is returned.
See section 11 below for more detail.
If \f[I]r\f[R] is omitted, \f[B]FS\f[R] is used.
.TP
sprintf(\f[I]format,expr-list\f[R])
Returns a string constructed from \f[I]expr-list\f[R] according to
\f[I]format\f[R].
See the description of printf() below.
.TP
sub(\f[I]r,s,t\f[R]) sub(\f[I]r,s\f[R])
Single substitution, same as gsub() except at most one substitution.
.TP
substr(\f[I]s,i,n\f[R]) substr(\f[I]s,i\f[R])
Returns the substring of string \f[I]s\f[R], starting at index
\f[I]i\f[R], of length \f[I]n\f[R].
If \f[I]n\f[R] is omitted, the suffix of \f[I]s\f[R], starting at
\f[I]i\f[R] is returned.
.TP
tolower(\f[I]s\f[R])
Returns a copy of \f[I]s\f[R] with all upper-case characters converted
to lower case.
.TP
toupper(\f[I]s\f[R])
Returns a copy of \f[I]s\f[R] with all lower-case characters converted
to upper case.
.SS Arithmetic functions
.IP
.nf
\f[C]
atan2(y,x)		Arctan of y/x between -\[*p] and \[*p].

cos(x)		Cosine function, x in radians.

exp(x)		Exponential function.

int(x)		Returns x truncated towards zero.

log(x)		Natural logarithm.

rand()		Returns a random number between zero and one.

sin(x)		Sine function, x in radians.

sqrt(x)		Returns square root of x.
\f[R]
.fi
.TP
srand(\f[I]expr\f[R]) srand()
Seeds the random number generator, using the clock if \f[I]expr\f[R] is
omitted, and returns the value of the previous seed.
\f[B]Wmawk2\f[R] seeds the random number generator from the clock at
startup so there is no real need to call srand().
Srand(\f[I]expr\f[R]) is useful for repeating pseudo random sequences.
.RS
.PP
systime() Returns the current time as the number of seconds since
.RS
.PP
1970-01-0100:00:00 UTC.
This always returns an integer number of seconds.
In April 2020 [just over 50 years after 1970-01-0100:00:00 UTC ] it
returned 1586616274.
.RE
.RE
.SS 9. Input and output
.PP
There are two output statements, \f[B]print\f[R] and \f[B]printf\f[R].
.TP
print
writes \f[B]$0 ORS\f[R] to standard output.
.TP
print \f[I]expr\f[R]1, \f[I]expr\f[R]2, ..., \f[I]expr\f[R]n
writes \f[I]expr\f[R]1 \f[B]OFS\f[R] \f[I]expr\f[R]2 \f[B]OFS\f[R] ...
\f[I]expr\f[R]n \f[B]ORS\f[R] to standard output.
Numeric expressions are converted to string with \f[B]OFMT\f[R].
.TP
printf \f[I]format, expr-list\f[R]
duplicates the printf C library function writing to standard output.
The complete ANSI C format specifications are recognized with
conversions %c, %d, %e, %E, %f, %g, %G, %i, %o, %s, %u, %x, %X and %%,
and conversion qualifiers h and l.
.PP
The argument list to print or printf can optionally be enclosed in
parentheses.
Print formats numbers using \f[B]OFMT\f[R] or \[dq]%d\[dq] for exact
integers.
\[dq]%c\[dq] with a numeric argument prints the corresponding 8 bit
character, with a string argument it prints the first character of the
string.
The output of print and printf can be redirected to a file or command by
appending > \f[I]file\f[R], >> \f[I]file\f[R] or | \f[I]command\f[R] to
the end of the print statement.
Redirection opens \f[I]file\f[R] or \f[I]command\f[R] only once,
subsequent redirections append to the already open stream.
By convention, \f[B]Wmawk2\f[R] associates the filename
\[dq]/dev/stderr\[dq] with stderr which allows print and printf to be
redirected to stderr.
\f[B]Wmawk2\f[R] also associates \[dq]-\[dq] and \[dq]/dev/stdout\[dq]
with stdin and stdout which allows these streams to be passed to
functions.
.PP
The input function \f[B]getline\f[R] has the following variations.
.TP
getline
reads into \f[B]$0\f[R], updates the fields, \f[B]NF\f[R], \f[B]NR\f[R]
and \f[B]FNR\f[R].
.TP
getline < \f[I]file\f[R]
reads into \f[B]$0\f[R] from \f[I]file\f[R], updates the fields and
\f[B]NF\f[R].
.TP
getline \f[I]var\f[R]
reads the next record into \f[I]var\f[R], updates \f[B]NR\f[R] and
\f[B]FNR\f[R].
.TP
getline \f[I]var\f[R] < \f[I]file\f[R]
reads the next record of \f[I]file\f[R] into \f[I]var\f[R].
.TP
\f[I]command\f[R] | getline
pipes a record from \f[I]command\f[R] into \f[B]$0\f[R] and updates the
fields and \f[B]NF\f[R].
.TP
\f[I]command\f[R] | getline \f[I]var\f[R]
pipes a record from \f[I]command\f[R] into \f[I]var\f[R].
.PP
Getline returns 0 on end-of-file, -1 on error, otherwise 1.
.PP
Commands on the end of pipes are executed by windows.
.PP
The function \f[B]close\f[R](\f[I]expr\f[R]) closes the file or pipe
associated with \f[I]expr\f[R].
Close returns 0 if \f[I]expr\f[R] is an open file, the exit status if
\f[I]expr\f[R] is a piped command, and -1 otherwise.
Close is used to reread a file or command, make sure the other end of an
output pipe is finished or conserve file resources.
.PP
The function \f[B]fflush\f[R](\f[I]expr\f[R]) flushes the output file or
pipe associated with \f[I]expr\f[R].
Fflush returns 0 if \f[I]expr\f[R] is an open output stream else -1.
Fflush without an argument flushes stdout.
Fflush with an empty argument (\[dq]\[dq]) flushes all open output.
.PP
The function \f[B]system\f[R](\f[I]expr\f[R]) uses Windows to execute
\f[I]expr\f[R] and returns the exit status of the command
\f[I]expr\f[R].
Changes made to the \f[B]ENVIRON\f[R] array are not passed to commands
executed with \f[B]system\f[R] or pipes.
.SS 10. User defined functions
.PP
The syntax for a user defined function is
.IP
.nf
\f[C]
	function name( args ) { statements }
\f[R]
.fi
.PP
The function body can contain a return statement
.IP
.nf
\f[C]
	return opt_expr
\f[R]
.fi
.PP
A return statement is not required.
Function calls may be nested or recursive.
Functions are passed expressions by value and arrays by reference.
Extra arguments serve as local variables and are initialized to
\f[I]null\f[R].
For example, csplit(\f[I]s,\[u2006]A\f[R]) puts each character of
\f[I]s\f[R] into array \f[I]A\f[R] and returns the length of
\f[I]s\f[R].
.IP
.nf
\f[C]
	function csplit(s, A,	n, i)
	{
	  n = length(s)
	  for( i = 1 ; i <= n ; i++ ) A[i] = substr(s, i, 1)
	  return n
	}
\f[R]
.fi
.PP
Putting extra space between passed arguments and local variables is
conventional.
Functions can be referenced before they are defined, but the function
name and the \[aq](\[aq] of the arguments must touch to avoid confusion
with concatenation.
.SS 11. Splitting strings, records and files
.PP
Awk programs use the same algorithm to split strings into arrays with
split(), and records into fields on \f[B]FS\f[R].
\f[B]Wmawk2\f[R] uses essentially the same algorithm to split files into
records on \f[B]RS\f[R].
.PP
Split(\f[I]expr,\[u2006]A,\[u2006]sep\f[R]) works as follows:
.TP
(1)
If \f[I]sep\f[R] is omitted, it is replaced by \f[B]FS\f[R].
\f[I]Sep\f[R] can be an expression or regular expression.
If it is an expression of non-string type, it is converted to string.
.TP
(2)
If \f[I]sep\f[R] = \[dq] \[dq] (a single space), then <SPACE> is trimmed
from the front and back of \f[I]expr\f[R], and \f[I]sep\f[R] becomes
<SPACE>.
\f[B]Wmawk2\f[R] defines <SPACE> as the regular expression /[
\[rs]t\[rs]n]+/.
Otherwise \f[I]sep\f[R] is treated as a regular expression, except that
meta-characters are ignored for a string of length 1, e.g., split(x, A,
\[dq]*\[dq]) and split(x, A, /\[rs]*/) are the same.
.TP
(3)
If \f[I]expr\f[R] is not string, it is converted to string.
If \f[I]expr\f[R] is then the empty string \[dq]\[dq], split() returns 0
and \f[I]A\f[R] is set empty.
Otherwise, all non-overlapping, non-null and longest matches of
\f[I]sep\f[R] in \f[I]expr\f[R], separate \f[I]expr\f[R] into fields
which are loaded into \f[I]A\f[R].
The fields are placed in A[1], A[2], ..., A[n] and split() returns n,
the number of fields which is the number of matches plus one.
Data placed in \f[I]A\f[R] that looks numeric is typed number and
string.
.PP
Splitting records into fields works the same except the pieces are
loaded into \f[B]$1\f[R], \f[B]$2\f[R],..., \f[B]$NF\f[R].
If \f[B]$0\f[R] is empty, \f[B]NF\f[R] is set to 0 and all \f[B]$i\f[R]
to \[dq]\[dq].
.PP
\f[B]Wmawk2\f[R] splits files into records by the same algorithm, but
with the slight difference that \f[B]RS\f[R] is really a terminator
instead of a separator.
(\f[B]ORS\f[R] is really a terminator too).
.RS
.PP
E.g., if \f[B]FS\f[R] = \[dq]:+\[dq] and \f[B]$0\f[R] = \[dq]a::b:\[dq]
, then \f[B]NF\f[R] = 3 and \f[B]$1\f[R] = \[dq]a\[dq], \f[B]$2\f[R] =
\[dq]b\[dq] and \f[B]$3\f[R] = \[dq]\[dq], but if \[dq]a::b:\[dq] is the
contents of an input file and \f[B]RS\f[R] = \[dq]:+\[dq], then there
are two records \[dq]a\[dq] and \[dq]b\[dq].
.RE
.PP
\f[B]RS\f[R] = \[dq] \[dq] is not special.
.PP
If \f[B]FS\f[R] = \[dq]\[dq], then \f[B]Wmawk2\f[R] breaks the record
into individual characters, and, similarly,
split(\f[I]s,A,\f[R]\[dq]\[dq]) places the individual characters of
\f[I]s\f[R] into \f[I]A\f[R].
.SS 12. Multi-line records
.PP
Since \f[B]Wmawk2\f[R] interprets \f[B]RS\f[R] as a regular expression,
multi-line records are easy.
Setting \f[B]RS\f[R] = \[dq]\[rs]n\[rs]n+\[dq], makes one or more blank
lines separate records.
If \f[B]FS\f[R] = \[dq] \[dq] (the default), then single newlines, by
the rules for <SPACE> above, become space and single newlines are field
separators.
.RS
.PP
For example, if a file is \[dq]a b\[rs]nc\[rs]n\[rs]n\[dq], \f[B]RS\f[R]
= \[dq]\[rs]n\[rs]n+\[dq] and \f[B]FS\f[R] = \[dq] \[dq], then there is
one record \[dq]a b\[rs]nc\[dq] with three fields \[dq]a\[dq],
\[dq]b\[dq] and \[dq]c\[dq].
Changing \f[B]FS\f[R] = \[dq]\[rs]n\[dq], gives two fields \[dq]a b\[dq]
and \[dq]c\[dq]; changing \f[B]FS\f[R] = \[dq]\[dq], gives one field
identical to the record.
.RE
.PP
If you want lines with spaces or tabs to be considered blank, set
\f[B]RS\f[R] = \[dq]\[rs]n([ \[rs]t]*\[rs]n)+\[dq].
For compatibility with other awks, setting \f[B]RS\f[R] = \[dq]\[dq] has
the same effect as if blank lines are stripped from the front and back
of files and then records are determined as if \f[B]RS\f[R] =
\[dq]\[rs]n\[rs]n+\[dq].
Posix requires that \[dq]\[rs]n\[dq] always separates records when
\f[B]RS\f[R] = \[dq]\[dq] regardless of the value of \f[B]FS\f[R].
\f[B]Wmawk2\f[R] does not support this convention, because defining
\[dq]\[rs]n\[dq] as <SPACE> makes it unnecessary.
.PP
Most of the time when you change \f[B]RS\f[R] for multi-line records,
you will also want to change \f[B]ORS\f[R] to \[dq]\[rs]n\[rs]n\[dq] so
the record spacing is preserved on output.
.SS 13. Program execution
.PP
This section describes the order of program execution.
First \f[B]ARGC\f[R] is set to the total number of command line
arguments passed to the execution phase of the program.
\f[B]ARGV[0]\f[R] is set the name of the AWK interpreter and
\f[B]ARGV[1]\f[R] ...
\f[B]ARGV[ARGC-1]\f[R] holds the remaining command line arguments
exclusive of options and program source.
For example with
.IP
.nf
\f[C]
	Wmawk2  -f  prog  v=1  A  t=hello  B
\f[R]
.fi
.PP
\f[B]ARGC\f[R] = 5 with \f[B]ARGV[0]\f[R] = \[dq]Wmawk2\[dq],
\f[B]ARGV[1]\f[R] = \[dq]v=1\[dq], \f[B]ARGV[2]\f[R] = \[dq]A\[dq],
\f[B]ARGV[3]\f[R] = \[dq]t=hello\[dq] and \f[B]ARGV[4]\f[R] =
\[dq]B\[dq].
.PP
Next, each \f[B]BEGIN\f[R] block is executed in order.
If the program consists entirely of \f[B]BEGIN\f[R] blocks, then
execution terminates, else an input stream is opened and execution
continues.
If \f[B]ARGC\f[R] equals 1, the input stream is set to stdin, else the
command line arguments \f[B]ARGV[1]\f[R]\[dq]\f[B]...\f[R]
\f[B]ARGV[ARGC-1]\f[R] are examined for a file argument.
.PP
The command line arguments divide into three sets: file arguments,
assignment arguments and empty strings \[dq]\[dq].
An assignment has the form \f[I]var\f[R]=\f[I]string\f[R].
When an \f[B]ARGV[i]\f[R] is examined as a possible file argument, if it
is empty it is skipped; if it is an assignment argument, the assignment
to \f[I]var\f[R] takes place and \f[B]i\f[R] skips to the next argument;
else \f[B]ARGV[i]\f[R] is opened for input.
If it fails to open, execution terminates with exit code 2.
If no command line argument is a file argument, then input comes from
stdin.
Getline in a \f[B]BEGIN\f[R] action opens input.
\[dq]-\[dq] as a file argument denotes stdin.
.PP
Once an input stream is open, each input record is tested against each
\f[I]pattern\f[R], and if it matches, the associated \f[I]action\f[R] is
executed.
An expression pattern matches if it is boolean true (see the end of
section 2).
A \f[B]BEGIN\f[R] pattern matches before any input has been read, and an
\f[B]END\f[R] pattern matches after all input has been read.
A range pattern, \f[I]expr\f[R]1,\[u2006]\f[I]expr\f[R]2 , matches every
record between the match of \f[I]expr\f[R]1 and the match
\f[I]expr\f[R]2 inclusively.
.PP
When end of file occurs on the input stream, the remaining command line
arguments are examined for a file argument, and if there is one it is
opened, else the \f[B]END\f[R] \f[I]pattern\f[R] is considered matched
and all \f[B]END\f[R] \f[I]actions\f[R] are executed.
.PP
In the example, the assignment v=1 takes place after the \f[B]BEGIN\f[R]
\f[I]actions\f[R] are executed, and the data placed in v is typed number
and string.
Input is then read from file A.
On end of file A, t is set to the string \[dq]hello\[dq], and B is
opened for input.
On end of file B, the \f[B]END\f[R] \f[I]actions\f[R] are executed.
.PP
Program flow at the \f[I]pattern\f[R] \f[I]{action}\f[R] level can be
changed with the
.IP
.nf
\f[C]
	next
	exit  opt_expr
\f[R]
.fi
.PP
statements.
A \f[B]next\f[R] statement causes the next input record to be read and
pattern testing to restart with the first \f[I]pattern {action}\f[R]
pair in the program.
An \f[B]exit\f[R] statement causes immediate execution of the
\f[B]END\f[R] actions or program termination if there are none or if the
\f[B]exit\f[R] occurs in an \f[B]END\f[R] action.
The \f[I]opt_expr\f[R] sets the exit value of the program unless
overridden by a later \f[B]exit\f[R] or subsequent error.
.PP
The nextfile statement causes wmawk2 to process stop processing the
current file and to start processing the next file specified on the
command line.
This means that FILENAME is changed, FNR is reset to 1 and processing
starts over with the first rule in the program.
.SH EXAMPLES
.IP
.nf
\f[C]
1. emulate cat.

	{ print }

2. emulate wc.

	{ chars += length($0) + 1  # add one for the \[rs]n
	  words += NF
	}

	END{ print NR, words, chars }

3. count the number of unique \[dq]real words\[dq].

	BEGIN { FS = \[dq][\[ha]A-Za-z]+\[dq] }

	{ for(i = 1 ; i <= NF ; i++)  word[$i] = \[dq]\[dq] }

	END { delete word[\[dq]\[dq]]
	      for ( i in word )  cnt++
	      print cnt
	}
\f[R]
.fi
.PP
4.
sum the second field of every record based on the first field.
.IP
.nf
\f[C]
	$1 \[ti] /credit\[u2006]|\[u2006]gain/ { sum += $2 }
	$1 \[ti] /debit\[u2006]|\[u2006]loss/  { sum -= $2 }

	END { print sum }

5. sort a file, comparing as string

	{ line[NR] = $0 \[dq]\[dq] }  # make sure of comparison type
			      # in case some lines look numeric

	END {  isort(line, NR)
	  for(i = 1 ; i <= NR ; i++) print line[i]
	}

	#insertion sort of A[1..n]
	function isort( A, n,	i, j, hold)
	{
	  for( i = 2 ; i <= n ; i++)
	  {
	    hold = A[j = i]
	    while ( A[j-1] > hold )
	    { j-\[u2006]- ; A[j+1] = A[j] }
	    A[j] = hold
	  }
	  # sentinel A[0] = \[dq]\[dq] will be created if needed
	}
\f[R]
.fi
.SH WHY USE AWK/MAWK/WMAWK ?
.PP
In general, awk is best at processing largeish text files that can be
basically processed a line at a time, it has no graphics support and
it\[cq]s a command line tool so it has no gui.
.PP
A good example is given at
<https://brenocon.com/blog/2009/09/dont-mawk-awk-the-fastest-and-most-elegant-big-data-munging-language/>
\&.
This example shows that mawk was both the fastest to execute (vs a range
of other languages as well as other awk implementations) and it only
tool 3 lines of awk to implement so was probably the fastest to write as
well.
.PP
If you want more information on awk in general then
<http://www.awklang.org/> is a good place to start.
.SH COMPATIBILITY ISSUES
.PP
The Posix 1003.2(draft 11.3) definition of the AWK language is AWK as
described in the AWK book with a few extensions that appeared in
SystemVR4 nawk.
The extensions are:
.RS
.PP
New functions: toupper() and tolower().
.PP
New variables: ENVIRON[\[u2006]] and CONVFMT.
.PP
ANSI C conversion specifications for printf() and sprintf().
.PP
New command options: -v var=value, multiple -f options and
implementation options as arguments to -W.
.RE
.PP
\f[B]Wmawk2\f[R] uses its own implementation of printf() and sprint() so
the functionality is fixed independent of the functionality in the
underlying C library functions.
This means that the Null character (\[rs]0) is allowed in the format
string and argument strings.
It also means that %d displays the number as a 64-bit integer.
The capabilities are print a character, %c; print a signed integer, %d
or %i ; print an unsigned integer, %u, %x, %X or %o; print a
floating-point number, %f, %g, %G, %e or %E ; print a string, %s.
An optional preceding l is allowed before an integer control character
(which is ignored).
An optional field width and precision as supported as usual.
The porter has tried to ensure the output is identical to that obtained
using gawk when run under Windows but that cannot be guaranteed for all
versions of gawk and all scripts/datasets.
\f[B]Wmawk2\f[R] also uses its own version of strtod() to convert
floating point numbers but this should not impact the underlying
functionality (this was done for speed rather than function).
It should be noted that \f[B]Wmawk2\f[R] does not recognize inf, nan or
hex string as numbers.
This means the data
.PP
0x4 inf nan
.PP
Passed to the script
.PP
{ print 7 + $1, 8 + $2, 9+$3}
.PP
Will result in
.PP
7 8 9
.PP
I.e., the 0x4 inf and nan are all treated as 0 when used as numbers.
This was done for backwards compatibility with earlier versions of awk.
.PP
Note that \f[B]Wmawk2\f[R] uses double precision floating point numbers
(as defined in IEE 754) internally where required.
These provide 15 to 17 significant digits (53 binary bits), have a
maximum value of +/- 1.797e+308 and a smallest non-zero number of
+/-4.94e-324.
As there are only 53 binary bits available in the mantissa, while
integers are printed by sprintf and printf to 64 bits not all of these
may be exact.
.PP
Posix AWK is oriented to operate on files a line at a time.
\f[B]RS\f[R] can be changed from \[dq]\[rs]n\[dq] to another single
character, but it is hard to find any use for this \[em] there are no
examples in the AWK book.
By convention, \f[B]RS\f[R] = \[dq]\[dq], makes one or more blank lines
separate records, allowing multi-line records.
When \f[B]RS\f[R] = \[dq]\[dq], \[dq]\[rs]n\[dq] is always a field
separator regardless of the value in \f[B]FS\f[R].
.PP
\f[B]Wmawk2\f[R], on the other hand, allows \f[B]RS\f[R] to be a regular
expression.
When \[dq]\[rs]n\[dq] appears in records, it is treated as space, and
\f[B]FS\f[R] always determines fields.
.PP
Removing the line at a time paradigm can make some programs simpler and
can often improve performance.
For example, redoing example 3 from above,
.IP
.nf
\f[C]
	BEGIN { RS = \[dq][\[ha]A-Za-z]+\[dq] }

	{ word[ $0 ] = \[dq]\[dq] }

	END { delete  word[ \[dq]\[dq] ]
	  for( i in word )  cnt++
	  print cnt
	}
\f[R]
.fi
.PP
counts the number of unique words by making each word a record.
On moderate size files, \f[B]Wmawk2\f[R] executes twice as fast, because
of the simplified inner loop.
.PP
The following program replaces each comment by a single space in a C
program file,
.IP
.nf
\f[C]
	BEGIN {
	  RS = \[dq]/\[u2006]\[rs]*([\[ha]*]\[u2006]|\[u2006]\[rs]*+[\[ha]/*])*\[rs]*+/\[dq]
		# comment is record separator
	  ORS = \[dq] \[dq]
	  getline  hold
       }

       { print hold ; hold = $0 }

       END { printf \[dq]%s\[dq] , hold }
\f[R]
.fi
.PP
Buffering one record is needed to avoid terminating the last record with
a space.
.PP
With \f[B]Wmawk2\f[R], the following are all equivalent,
.IP
.nf
\f[C]
	x \[ti] /a\[rs]+b/    x \[ti] \[dq]a\[rs]+b\[dq]     x \[ti] \[dq]a\[rs]\[rs]+b\[dq]
\f[R]
.fi
.PP
The strings get scanned twice, once as string and once as regular
expression.
On the string scan, \f[B]Wmawk2\f[R] ignores the escape on non-escape
characters while the AWK book advocates \f[I]\[rs]c\f[R] be recognized
as \f[I]c\f[R] which necessitates the double escaping of meta-characters
in strings.
Posix explicitly declines to define the behavior which passively forces
programs that must run under a variety of awks to use the more portable
but less readable, double escape.
.PP
Posix AWK does not recognize \[dq]/dev/std{out,err}\[dq] or \[rs]x hex
escape sequences in strings.
Unlike ANSI C, \f[B]Wmawk2\f[R] limits the number of digits that follows
\[rs]x to two as the current implementation only supports 8-bit
characters.
The built-in \f[B]fflush\f[R] first appeared in a recent (1993) AT&T awk
released to netlib, and is not part of the posix standard.
Aggregate deletion with \f[B]delete\f[R] \f[I]array\f[R] is not part of
the posix standard.
.PP
Posix explicitly leaves the behavior of \f[B]FS\f[R] = \[dq]\[dq]
undefined, and mentions splitting the record into characters as a
possible interpretation, but currently this use is not portable across
implementations.
.PP
Finally, here is how \f[B]Wmawk2\f[R] handles exceptional cases not
discussed in the AWK book or the Posix draft.
It is unsafe to assume consistency across awks and safe to skip to the
next section.
.RS
.PP
substr(s, i, n) returns the characters of s in the intersection of the
closed interval [1, length(s)] and the half-open interval [i, i+n).
When this intersection is empty, the empty string is returned; so
substr(\[dq]ABC\[dq], 1, 0) = \[dq]\[dq] and substr(\[dq]ABC\[dq], -4,
6) = \[dq]A\[dq].
.PP
Every string, including the empty string, matches the empty string at
the front so, s \[ti] // and s \[ti] \[dq]\[dq], are always 1 as is
match(s, //) and match(s, \[dq]\[dq]).
The last two set \f[B]RLENGTH\f[R] to 0.
.PP
index(s, t) is always the same as match(s, t1) where t1 is the same as t
with metacharacters escaped.
Hence consistency with match requires that index(s, \[dq]\[dq]) always
returns 1.
Also the condition, index(s,t) != 0 if and only t is a substring of s,
requires index(\[dq]\[dq],\[dq]\[dq]) = 1.
.PP
If getline encounters end of file, getline var, leaves var unchanged.
Similarly, on entry to the \f[B]END\f[R] actions, \f[B]$0\f[R], the
fields and \f[B]NF\f[R] have their value unaltered from the last record.
.RE
.PP
Note that gawk has a number of extensions that are not present in
mawk/Wmawk2.
In general, these are easy to work around with awk scripts.
As an example, sorting can be done with the functions in the qsort.awk
program in the examples directory, the script at
<https://docstore.mik.ua/orelly/unix3/sedawk/ch09_03.htm> or you can use
the sort program at <https://github.com/p-j-miller/nsort> either via
pipes or by using the awk system command.
.SH SEE ALSO
.PP
\f[I]egrep\f[R](1)
.PP
Aho, Kernighan and Weinberger, \f[I]The AWK Programming Language\f[R],
Addison-Wesley Publishing, 1988, (the AWK book), defines the language,
opening with a tutorial and advancing to many interesting programs that
delve into issues of software design and analysis relevant to
programming in any language.
.PP
\f[I]<https://dev.to/rrampage/awk---a-useful-little-language-2fhf> a
useful, but basic introduction to awk.\f[R]
.PP
\f[I]The GAWK Manual\f[R], The Free Software Foundation, 1991, is a
tutorial and language reference that does not attempt the depth of the
AWK book and assumes the reader may be a novice programmer.
The section on AWK arrays is excellent.
It also discusses Posix requirements for AWK.
.PP
<http://www.awklang.org/> which claims to be the site for things related
to the awk language.
This includes links to 5 awk books., tutorials and a number of examples
including one that can be run live on the web site to deal the cards for
poker hands.
.PP
<https://github.com/e36freak/awk-libs> a library of awk functions
including a number of different sorts, extra functions for math\[cq]s,
strings, csv files, etc.
.SH BUGS
.PP
\f[B]Wmawk2\f[R] cannot handle ascii NUL \[rs]0 in source (script)
files.
It is allowed in data files, and you can output NUL using printf with %c
or by printing a string containing a NUL character.
.PP
Implementors of the AWK language have shown a consistent lack of
imagination when naming their programs.
.SH INSTALLATION
.PP
The executable (for 64-bit windows) and this manual as a pdf are
available from github at <https://github.com/p-j-miller/wmawk2> .
The executable is a portable program and may be placed anywhere (even on
removable media).
It is suggested that you place the directory where the executable is on
your PATH (it\[cq]s easy to find instructions on how to do this on the
web for example search \[lq]adding a directory to path windows 10\[rq])
\[en] if this is not done then you need to include the path to the
executable to invoke \f[B]Wmawk2\f[R] if you are not in the same
directory as the executable.
.PP
Alternatively, you can compile from source \[en] a dev-c++ project file
is provided in the github repository which assumes the use of TDM-GCC
9.2.0 .
.SH AUTHOR
.PP
This windows port was created by Peter Miller.
.PP
Mawk was written by Mike Brennan.
.SH LICENSE
.PP
\f[B]Wmawk2\f[R] is distributed without warranty under the terms of the
GNU General Public License, version 3, 2007.
.PP
The file atof.c is under the MIT license (see sources code).
.PP
The source code is available from <https://github.com/p-j-miller/wmawk2>
