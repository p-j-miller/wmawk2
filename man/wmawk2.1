.\" Automatically generated by Pandoc 3.4
.\"
.TH "Wmawk2" "" "Version 2.0, September 22^nd^ 2024" ""
.SH NAME
Wmawk2 \- pattern scanning and text processing language
.SH SYNOPSIS
\f[B]Wmawk2\f[R] [\-\f[B]W\f[R] \f[I]option\f[R]] [\-\f[B]F\f[R]
\f[I]value\f[R]] [\-\f[B]v\f[R] \f[I]var=value\f[R]] [\- \-]
\[aq]program text\[aq] [file ...]
.PD 0
.P
.PD
\f[B]Wmawk2\f[R] [\-\f[B]W\f[R] \f[I]option\f[R]] [\-\f[B]F\f[R]
\f[I]value\f[R]] [\-\f[B]v\f[R] \f[I]var=value\f[R]] [\-\f[B]f\f[R]
\f[I]program\-file\f[R]] [\- \-] [file ...]
.SH DESCRIPTION
\f[B]Wmawk2\f[R] is an interpreter for the AWK Programming Language.
The AWK language is useful for manipulation of data files, text
retrieval and processing, and for prototyping and experimenting with
algorithms.
\f[B]Wmawk2\f[R] is a \f[I]new awk\f[R] meaning it implements the AWK
language as defined in Aho, Kernighan and Weinberger, \f[I]The AWK
Programming Language,\f[R] Addison\-Wesley Publishing, 1988.
(Hereafter referred to as the AWK book.)
\f[B]Wmawk2\f[R] conforms to the Posix 1003.2 (draft 11.3) definition of
the AWK language which contains a few features not described in the AWK
book, and \f[B]Wmawk2\f[R] provides a small number of extensions.
.PP
\f[B]Wmawk2\f[R] a port of mawk 1.9.9.6 to Windows.
It was created because the version of on github (
https://github.com/mikebrennan000/mawk\-2 ) did not compile for Windows
when using tdm\-gcc 9.2.2, and when these issues were resolved the
system command did not work.
The systime() function was also added.
.PP
An AWK program is a sequence of \f[I]pattern {action}\f[R] pairs and
function definitions.
Short programs are entered on the command line usually enclosed in
\[lq]..\[rq] to avoid shell interpretation.
Note that \[lq]inner\[rq] quotes then need to be escaped as shown in the
example below:
.PP
wmawk2 \[dq]BEGIN{print \[rs]\[dq]€\[rs]\[dq]}\[dq]
.PP
To get a \[rs] it needs to be escaped as in:
.PP
wmawk2 \[dq]BEGIN {print \[rs]\[dq]\[rs]\[rs] \[rs]\[dq]}\[dq]
.PP
which prints
.PP
\[rs]
.PP
Note there is a space after the third \[oq]\[rs]\[cq] character.
.PP
Longer programs can be read in from a file with the \-f option.
Data input is read from the list of files on the command line or from
standard input when the list is empty.
The input is broken into records as determined by the record separator
variable, \f[B]RS\f[R].
Initially, \f[B]RS\f[R] = \[dq]\[rs]n\[dq] and records are synonymous
with lines.
Each record is compared against each \f[I]pattern\f[R] and if it
matches, the program text for \f[I]{action}\f[R] is executed.
.PP
Also note that when reading text interactively from stdin the arrow
keys, backspace and delete can be used to edit the line before pressing
Enter.
To signify EOF you need to type CONTROL\-Z followed by Enter.
Normally the CONTROL\-Z character should be the first character on the
line, if there are characters before the CONTROL\-Z they will be passed
to the awk script before EOF is detected.
Any characters on a line after a CONTROL\-Z are lost.
There is a maximum line length on interactive input (8192 utf8
characters) \[en] this is the only fixed limit in wmawk2.
The command line to wmawk2 will be subject to limits depending on how it
is called, but 32767 characters is believed to be the maximum possible
in Windows 10 (and it may be significantly lower in some cases) \[en]
but this is not a limitation of wmawk2.
.SH OPTIONS
.TP
\-F \f[I]value\f[R]
sets the field separator, \f[B]FS\f[R], to \f[I]value\f[R].
.TP
\-f \f[I]file\f[R]
Program text is read from \f[I]file\f[R] instead of from the command
line.
Multiple \f[B]\-f\f[R] options are allowed.
.TP
\-v \f[I]var=value\f[R]
assigns \f[I]value\f[R] to program variable \f[I]var\f[R].
.TP
\- \-
indicates the unambiguous end of options.
.PP
The above options will be available with any Posix compatible
implementation of AWK, and implementation specific options are prefaced
with \f[B]\-W\f[R].
\f[B]Wmawk2\f[R] provides seven:
.TP
\-W version
\f[B]Wmawk2\f[R] writes its version and copyright to stdout and compiled
limits to stderr and exits 0.
.TP
\-W dump
writes an assembler like listing of the internal representation of the
program to stdout and exits 0 (on successful compilation).
.TP
\-W interactive
sets unbuffered writes to stdout and line buffered reads from stdin.
Records from stdin are lines regardless of the value of \f[B]RS\f[R].
.TP
\-W exec \f[I]file\f[R]
Program text is read from \f[I]file\f[R] and this is the last option.
.TP
\-W sprintf=\f[I]num\f[R]
This option is obsolete, its left for backwards compatibility with mawk
version 1.
.TP
\-W traditional
This option disables Wmawk2 extensions (like systime()) which are not in
the original mawk2.
These are marked \[lq]\f[CR]Wmawk2 extension\[rq] in this manual.\f[R]
.TP
\-W posix_space
forces \f[B]Wmawk2\f[R] not to consider \[aq]\[rs]n\[aq] to be space.
.PP
The short forms \f[B]\-W\f[R][vdiestp] are recognized.
.PP
Note that the space after \-W is optional, and upper and lower case are
equivalent.
Options can also be abbreviated so \-W t, \-Wt, \-W T, \-W trad, \-W
Traditional are all equivalent.
.SH THE AWK LANGUAGE
.SS 1. Program structure
An AWK program is a sequence of \f[I]pattern {action}\f[R] pairs and
user function definitions.
.PP
A pattern can be:
.IP
.EX
BEGIN
END
expression
expression , expression
.EE
.PP
One, but not both, of \f[I]pattern {action}\f[R] can be omitted.
If \f[I]{action}\f[R] is omitted it is implicitly {print}.
If \f[I]pattern\f[R] is omitted, then it is implicitly matched.
\f[B]BEGIN\f[R] and \f[B]END\f[R] patterns require an action.
.PP
Statements are terminated by newlines, semi\-colons or both.
Groups of statements such as actions or loop bodies are blocked via {
\&...
} as in C. The last statement in a block doesn\[aq]t need a terminator.
Blank lines have no meaning; an empty statement is terminated with a
semi\-colon.
Long statements can be continued with a backslash, \[rs] .
A statement can be broken without a backslash after a comma, left brace,
&&, ||, \f[B]do\f[R], \f[B]else\f[R], the right parenthesis of an
\f[B]if\f[R], \f[B]while\f[R] or \f[B]for\f[R] statement, and the right
parenthesis of a function definition.
A comment starts with # and extends to, but does not include the end of
line.
.PP
The following statements control program flow inside blocks.
.RS
.PP
\f[B]if\f[R] ( \f[I]expr\f[R] ) \f[I]statement\f[R]
.PP
\f[B]if\f[R] ( \f[I]expr\f[R] ) \f[I]statement\f[R] \f[B]else\f[R]
\f[I]statement\f[R]
.PP
\f[B]while\f[R] ( \f[I]expr\f[R] ) \f[I]statement\f[R]
.PP
\f[B]do\f[R] \f[I]statement\f[R] \f[B]while\f[R] ( \f[I]expr\f[R] )
.PP
\f[B]for\f[R] ( \f[I]opt_expr\f[R] ; \f[I]opt_expr\f[R] ;
\f[I]opt_expr\f[R] ) \f[I]statement\f[R]
.PP
\f[B]for\f[R] ( \f[I]var\f[R] \f[B]in\f[R] \f[I]array\f[R] )
\f[I]statement\f[R]
.PP
\f[B]continue\f[R]
.PP
\f[B]break\f[R]
.RE
.SS 2. Data types, conversion and comparison
There are two basic data types, numeric and string.
Numeric constants can be integer like \-2, decimal like 1.08, or in
scientific notation like \-1.1e4 or .28E\-3.
All numbers are represented internally and all computations are done in
floating point arithmetic.
So, for example, the expression 0.2e2 == 20 is true and true is
represented as 1.0.
Wmawk2 version 2.0 and above also allow hexadecimal constants (only) in
awk scripts prefixed by 0X or 0x, e.g.
0xff is equivalent to the decimal number 255.
Earlier versions of Wmawk2 would consider numeric constants starting 0x
or 0X to be equal to zero (so 0xff would be considered as 0).
Octal constants are not supported by Wmawk2 (as this could change the
meaning of some existing programs as 010 is 8 in octal, but 10 in
decimal).
.PP
String constants are enclosed in double quotes.
.PP
\[dq]This is a string with a newline at the end.\[rs]n\[dq]
.PP
Strings can be continued across a line by escaping (\[rs]) the newline.
The following escape sequences are recognized.
.IP
.EX

	\[rs]\[rs]		\[rs]
	\[rs]\[dq]		\[dq]
	\[rs]a		alert, ascii 7
	\[rs]b		backspace, ascii 8
	\[rs]t		tab, ascii 9
	\[rs]n		newline, ascii 10
	\[rs]v		vertical tab, ascii 11
	\[rs]f		formfeed, ascii 12
	\[rs]r		carriage return, ascii 13
	\[rs]ddd		1, 2 or 3 octal digits for ascii ddd
	\[rs]xhh		1 or 2 hex digits for ascii  hh
.EE
.PP
If you escape any other character \[rs]c, you get \[rs]c, i.e.,
\f[B]Wmawk2\f[R] ignores the escape.
.PP
Note that in replacement strings \[rs] escapes \[rs] and \[rs] escapes
&, but only if the run of \[rs] ends in & so that the script
{sub(/B/,\[dq]\[rs]\[rs]\[rs]\[rs]\[dq]) ; print} fed with the input ABC
will give A\[rs]\[rs]C
.PP
There are really three basic data types; the third is \f[I]number and
string\f[R] which has both a numeric value and a string value at the
same time.
User defined variables come into existence when first referenced and are
initialized to \f[I]null\f[R], a number and string value which has
numeric value 0 and string value \[dq]\[dq].
Non\-trivial number and string typed data come from input and are
typically stored in fields.
(See section 4).
.PP
The type of an expression is determined by its context and automatic
type conversion occurs if needed.
For example, to evaluate the statements
.IP
.EX

	y = x + 2;  z = x  \[dq]hello\[dq]
.EE
.PP
The value stored in variable y will be typed numeric.
If x is not numeric, the value read from x is converted to numeric
before it is added to 2 and stored in y.
The value stored in variable z will be typed string, and the value of x
will be converted to string if necessary and concatenated with
\[dq]hello\[dq].
(Of course, the value and type stored in x is not changed by any
conversions.)
A string expression is converted to numeric using its longest numeric
prefix as with the C function \f[I]atof\f[R]().
A numeric expression is converted to string by replacing \f[I]expr\f[R]
with \f[B]sprintf(CONVFMT\f[R], \f[I]expr\f[R]), unless \f[I]expr\f[R]
can be represented on the host machine as an exact integer then it is
converted to \f[B]sprintf\f[R](\[dq]%d\[dq], \f[I]expr\f[R]).
\f[B]Sprintf()\f[R] is an AWK built\-in that duplicates the
functionality of the C function \f[I]sprintf\f[R](), and
\f[B]CONVFMT\f[R] is a built\-in variable used for internal conversion
from number to string and initialized to \[dq]%.6g\[dq].
Explicit type conversions can be forced, \f[I]expr\f[R] \[dq]\[dq] is
string and \f[I]expr\f[R]+0 is numeric.
.PP
To evaluate, \f[I]expr\f[R]1 \f[B]rel\-op\f[R] \f[I]expr\f[R]2, if both
operands are numeric or number and string then the comparison is
numeric; if both operands are string the comparison is string; if one
operand is string, the non\-string operand is converted and the
comparison is string.
The result is numeric, 1 or 0.
.PP
In boolean contexts such as, \f[B]if\f[R] ( \f[I]expr\f[R] )
\f[I]statement\f[R], a string expression evaluates true if and only if
it is not the empty string \[dq]\[dq]; numeric values if and only if not
numerically zero.
.SS 3. Regular expressions
In the AWK language, records, fields and strings are often tested for
matching a \f[I]regular expression\f[R].
Regular expressions are enclosed in slashes, and
.IP
.EX

	expr \[ti] /r/
.EE
.PP
is an AWK expression that evaluates to 1 if \f[I]expr\f[R]
\[dq]matches\[dq] \f[I]r\f[R], which means a substring of \f[I]expr\f[R]
is in the set of strings defined by \f[I]r\f[R].
With no match the expression evaluates to 0; replacing \[ti] with the
\[dq]not match\[dq] operator, !\[ti] , reverses the meaning.
As pattern\-action pairs,
.IP
.EX

	/r/ { action }   and   $0 \[ti] /r/ { action }
.EE
.PP
are the same, and for each input record that matches \f[I]r\f[R],
\f[I]action\f[R] is executed.
In fact, /\f[I]r\f[R]/ is an AWK expression that is equivalent to
(\f[B]$0\f[R] \[ti] /\f[I]r\f[R]/) anywhere except when on the right
side of a match operator or passed as an argument to a built\-in
function that expects a regular expression argument.
.PP
AWK uses extended regular expressions as with the UNIX/Linux command
\f[I]egrep\f[R].
The regular expression metacharacters, i.e., those with special meaning
in regular expressions are
.IP
.EX

	 \[ha] $ . [ ] | ( ) * + ?
.EE
.PP
Regular expressions are built up from characters as follows:
.TP
\f[I]c\f[R]
matches any non\-metacharacter \f[I]c\f[R].
.TP
\[rs]\f[I]c\f[R]
matches a character defined by the same escape sequences used in string
constants or the literal character \f[I]c\f[R] if \[rs]\f[I]c\f[R] is
not an escape sequence.
.TP
\&.
matches any character (including newline).
.TP
\[ha]
matches the front of a string.
.TP
$
matches the back of a string.
.TP
[c1c2c3...]
matches any character in the class c1c2c3...
\&.
An interval of characters is denoted c1\-c2 inside a class [...].
.TP
[\[ha]c1c2c3...]
matches any character not in the class c1c2c3...
.RS
.PP
Character classes are also support, these can only be used inside the
brackets of a regular expression and define groups of characters in a
portable manner (e.g., /[[:digit:]]/ ).
The list that are supported by Wmawk2 is: alnum, alpha, blank, cntrl,
digit, graph, lower, print, space, upper, xdigit.
These are defined as:
.RE
\[bu] .RS 2
.PP
alnum \[en] alphanumeric characters (typically a\-z A\-Z 0\-9)
.RE
\[bu] .RS 2
.PP
alpha \[en] alphabetic characters (typically a\-z A\-Z)
.RE
\[bu] .RS 2
.PP
blank \[en] space and tab characters
.RE
\[bu] .RS 2
.PP
cntrl \[en] control characters
.RE
\[bu] .RS 2
.PP
digit \[en] typically 0\-9
.RE
\[bu] .RS 2
.PP
graph \[en] characters that are both printable and visible (e.g., a
space is not visible)
.RE
\[bu] .RS 2
.PP
lower \[en] lower case alphabetic characters (typically a\-z)
.RE
\[bu] .RS 2
.PP
print \[en] printable characters (characters that are not control
characters)
.RE
\[bu] .RS 2
.PP
space \[en] typically space, tab, newline, carriage return, formfeed and
vertical tab.
.RE
\[bu] .RS 2
.PP
Upper \- upper case alphabetic characters (typically A\-Z)
.RE
\[bu] .RS 2
.PP
Xdigit \[en] hex digits (typically 0\-9 a\-f A\-F)
.RE
.PP
Regular expressions are built up from other regular expressions as
follows:
.TP
\f[I]r\f[R]1\f[I]r\f[R]2
matches \f[I]r\f[R]1 followed immediately by \f[I]r\f[R]2
(concatenation).
.TP
\f[I]r\f[R]1 | \f[I]r\f[R]2
matches \f[I]r\f[R]1 or \f[I]r\f[R]2 (alternation).
.TP
\f[I]r\f[R]*
matches \f[I]r\f[R] repeated zero or more times.
.TP
\f[I]r\f[R]+
matches \f[I]r\f[R] repeated one or more times.
.TP
\f[I]r\f[R]?
matches \f[I]r\f[R] zero or once.
.TP
(\f[I]r\f[R])
matches \f[I]r\f[R], providing grouping.
.PP
The increasing precedence of operators is alternation, concatenation and
unary (*, + or ?).
.PP
For example,
.IP
.EX

	/\[ha][_a\-zA\-Z][_a\-zA\-Z0\-9]*$/  and
	/\[ha][\-+]?([0\-9]+\[rs] .?|\[rs] .[0\-9])[0\-9]*([eE][\-+]?[0\-9]+)?$/
.EE
.PP
are matched by AWK identifiers and AWK numeric constants respectively.
Note that .
has to be escaped to be recognized as a decimal point, and that
metacharacters are not special inside character classes.
.PP
Any expression can be used on the right\-hand side of the \[ti] or
!\[ti] operators or passed to a built\-in that expects a regular
expression.
If needed, it is converted to string, and then interpreted as a regular
expression.
For example,
.IP
.EX

	BEGIN { identifier = \[dq][_a\-zA\-Z][_a\-zA\-Z0\-9]*\[dq] }

	$0 \[ti] \[dq]\[ha]\[dq] identifier
.EE
.PP
prints all lines that start with an AWK identifier.
.PP
\f[B]Wmawk2\f[R] recognizes the empty regular expression, // , which
matches the empty string and hence is matched by any string at the
front, back and between every character.
For example,
.IP
.EX

	echo  abc | Wmawk2 { gsub(//, \[dq]X\[dq]) ; print }
	XaXbXcX
.EE
.SS 4. Records and fields
Records are read in one at a time, and stored in the \f[I]field\f[R]
variable \f[B]$0\f[R].
The record is split into \f[I]fields\f[R] which are stored in
\f[B]$1\f[R], \f[B]$2\f[R], ..., \f[B]$NF\f[R].
The built\-in variable \f[B]NF\f[R] is set to the number of fields, and
\f[B]NR\f[R] and \f[B]FNR\f[R] are incremented by 1.
Fields above \f[B]$NF\f[R] are set to \[dq]\[dq].
.PP
Assignment to \f[B]$0\f[R] causes the fields and \f[B]NF\f[R] to be
recomputed.
Assignment to \f[B]NF\f[R] or to a field causes \f[B]$0\f[R] to be
reconstructed by concatenating the \f[B]$i\[aq]s\f[R] separated by
\f[B]OFS\f[R].
Assignment to a field with index greater than \f[B]NF\f[R], increases
\f[B]NF\f[R] and causes \f[B]$0\f[R] to be reconstructed.
.PP
Data input stored in fields is string, unless the entire field has
numeric form and then the type is number and string.
For example,
.IP
.EX
	echo 24 24E | 
	Wmawk2 \[aq]{ print($1>100, $1>\[dq]100\[dq], $2>100, $2>\[dq]100\[dq]) }\[aq]
	0 1 1 1
.EE
.PP
\f[B]$0\f[R] and \f[B]$2\f[R] are string and \f[B]$1\f[R] is number and
string.
The first comparison is numeric, the second is string, the third is
string (100 is converted to \[dq]100\[dq]), and the last is string.
.SS 5. Expressions and operators
The expression syntax is similar to C. Primary expressions are numeric
constants, string constants, variables, fields, arrays and function
calls.
The identifier for a variable, array or function can be a sequence of
letters, digits and underscores, that does not start with a digit.
Variables are not declared; they exist when first referenced and are
initialized to \f[I]null\f[R].
.PP
New expressions are composed with the following operators in order of
increasing precedence.
.IP
.EX
assignment		=  +=  \-=  *=  /=  %=  \[ha]=
conditional		?  :
logical or		||
logical and		&&
array membership	in
matching		\[ti]   !\[ti]
relational		<  >   <=  >=  ==  !=
concatenation	(no explicit operator)
add ops		+  \-
mul ops		*  /  % 
unary			+  \-
logical not		!
exponentiation	\[ha]
inc and dec		++ \- \- (both post and pre)
field			$
.EE
.RS
.PP
Assignment, conditional and exponentiation associate right to left; the
other operators associate left to right.
Any expression can be parenthesized.
.RE
.SS 6. Arrays
Awk provides one\-dimensional arrays.
Array elements are expressed as \f[I]array\f[R][\f[I]expr\f[R]].
\f[I]Expr\f[R] is internally converted to string type, so, for example,
A[1] and A[\[dq]1\[dq]] are the same element and the actual index is
\[dq]1\[dq].
Arrays indexed by strings are called associative arrays.
Initially an array is empty; elements exist when first accessed.
An expression, \f[I]expr\f[R] \f[B]in\f[R] \f[I]array\f[R] evaluates to
1 if \f[I]array\f[R][\f[I]expr\f[R]] exists, else to 0.
.PP
There is a form of the \f[B]for\f[R] statement that loops over each
index of an array.
.IP
.EX

	for ( var in array ) statement
.EE
.PP
sets \f[I]var\f[R] to each index of \f[I]array\f[R] and executes
\f[I]statement\f[R].
The order that \f[I]var\f[R] transverses the indices of \f[I]array\f[R]
is not defined.
.PP
The statement, \f[B]delete\f[R] \f[I]array\f[R][\f[I]expr\f[R]], causes
\f[I]array\f[R][\f[I]expr\f[R]] not to exist.
\f[B]Wmawk2\f[R] also allows \f[B]delete\f[R] \f[I]array\f[R], which
deletes all elements of \f[I]array\f[R].
.PP
Multidimensional arrays are synthesized with concatenation using the
built\-in variable \f[B]SUBSEP\f[R].
\f[I]array\f[R][\f[I]expr\f[R]1, \f[I]expr\f[R]2] is equivalent to
\f[I]array\f[R][\f[I]expr\f[R]1 \f[B]SUBSEP\f[R] \f[I]expr\f[R]2].
Testing for a multidimensional element uses a parenthesized index, such
as
.IP
.EX
	if ( (i, j) in A )  print A[i, j]
.EE
.SS 7. Builtin\-variables
The following variables are built\-in and initialized before program
execution.
.TP
ARGC
number of command line arguments.
.TP
ARGV
array of command line arguments, 0..ARGC\-1.
.TP
CONVFMT
format for internal conversion of numbers to string, initially =
\[dq]%.6g\[dq].
.TP
ENVIRON
array indexed by environment variables.
An environment string, \f[I]var=value\f[R] is stored as
\f[B]ENVIRON\f[R][\f[I]var\f[R]] = \f[I]value\f[R].
.TP
FILENAME
name of the current input file.
.TP
FNR
current record number in \f[B]FILENAME\f[R].
.TP
FS
splits records into fields as a regular expression.
.TP
NF
number of fields in the current record.
.TP
NR
current record number in the total input stream.
.TP
OFMT
format for printing numbers; initially = \[dq]%.6g\[dq].
.TP
OFS
inserted between fields on output, initially = \[dq] \[dq].
.TP
ORS
terminates each record on output, initially = \[dq]\[rs]n\[dq].
.TP
RLENGTH
length set by the last call to the built\-in function,
\f[B]match()\f[R].
.TP
RS
input record separator, initially = \[dq]\[rs]n\[dq].
.TP
RSTART
index set by the last call to \f[B]match()\f[R].
.TP
SUBSEP
used to build multiple array subscripts, initially = \[dq]\[rs]034\[dq].
.SS 8. Built\-in functions
.SS String functions
.TP
gsub(\f[I]r,s,t\f[R]) gsub(\f[I]r,s\f[R])
Global substitution, every match of regular expression \f[I]r\f[R] in
variable \f[I]t\f[R] is replaced by string \f[I]s\f[R].
The number of replacements is returned.
If \f[I]t\f[R] is omitted, \f[B]$0\f[R] is used.
An & in the replacement string \f[I]s\f[R] is replaced by the matched
substring of \f[I]t\f[R].
\[rs]& and \[rs]\[rs] put literal & and \[rs], respectively, in the
replacement string.
.TP
index(\f[I]s,t\f[R])
If \f[I]t\f[R] is a substring of \f[I]s\f[R], then the position where
\f[I]t\f[R] starts is returned, else 0 is returned.
The first character of \f[I]s\f[R] is in position 1.
.TP
length(\f[I]s\f[R])
Returns the length of string \f[I]s\f[R].
.RS
.PP
If s is an array length returns the number of elements in the array.
.RE
.TP
match(\f[I]s,r\f[R])
Returns the index of the first longest match of regular expression
\f[I]r\f[R] in string \f[I]s\f[R].
Returns 0 if no match.
As a side effect, \f[B]RSTART\f[R] is set to the return value.
\f[B]RLENGTH\f[R] is set to the length of the match or \-1 if no match.
If the empty string is matched, \f[B]RLENGTH\f[R] is set to 0, and 1 is
returned if the match is at the front, and length(\f[I]s\f[R])+1 is
returned if the match is at the back.
.TP
split(\f[I]s,A,r\f[R]) split(\f[I]s,A\f[R])
String \f[I]s\f[R] is split into fields by regular expression
\f[I]r\f[R] and the fields are loaded into array \f[I]A\f[R].
The number of fields is returned.
See section 11 below for more detail.
If \f[I]r\f[R] is omitted, \f[B]FS\f[R] is used.
.TP
sprintf(\f[I]format,expr\-list\f[R])
Returns a string constructed from \f[I]expr\-list\f[R] according to
\f[I]format\f[R].
See the description of printf() below.
.TP
sub(\f[I]r,s,t\f[R]) sub(\f[I]r,s\f[R])
Single substitution, same as gsub() except at most one substitution.
.TP
substr(\f[I]s,i,n\f[R]) substr(\f[I]s,i\f[R])
Returns the substring of string \f[I]s\f[R], starting at index
\f[I]i\f[R], of length \f[I]n\f[R].
If \f[I]n\f[R] is omitted, the suffix of \f[I]s\f[R], starting at
\f[I]i\f[R] is returned.
.TP
tolower(\f[I]s\f[R])
Returns a copy of \f[I]s\f[R] with all upper\-case characters converted
to lower case.
.TP
toupper(\f[I]s\f[R])
Returns a copy of \f[I]s\f[R] with all lower\-case characters converted
to upper case.
.SS Arithmetic functions
.IP
.EX
atan2(y,x)		Arctan of y/x between \-π and π.

cos(x)		Cosine function, x in radians.

exp(x)		Exponential function.

int(x)		Returns x truncated towards zero.

log(x)		Natural logarithm.

rand()		Returns a random number between zero and one.

sin(x)		Sine function, x in radians.

sqrt(x)		Returns square root of x.
.EE
.PP
\f[CR]srand\f[R]\f[CR](expr) \f[R]
.TP
\f[CR]srand\f[R]\f[CR](\f[R]\f[CR])\f[R]
.RS
.PP
\f[CR]Seeds the random number generator, using the clock if expr is omitted, and returns the value of the previous seed. Wmawk2 seeds the random number generator from the clock at startup so there is no real need to call \f[R]\f[CR]srand\f[R]\f[CR](\f[R]\f[CR]). \f[R]\f[CR]Srand\f[R]\f[CR](expr) is useful for repeating pseudo random sequences.\f[R]
.RE
.RS
.RS
.PP
\f[CR]If you need a \f[R]\f[CR]pseudo \f[R]\f[CR]random number\f[R]\f[CR] generator\f[R]\f[CR] \f[R]\f[CR]t\f[R]\f[CR]hat will \f[R]\f[CR]give the s\f[R]\f[CR]ame \f[R]\f[CR]sequence of random numbers \f[R]\f[CR]on all a\f[R]\f[CR]w\f[R]\f[CR]k\f[R]\f[CR] imple\f[R]\f[CR]mentations see \f[R]\f[CR]prand.awk\f[R]\f[CR] in \f[R]\f[CR]AWK\-\f[R]\f[CR]library\f[R]\f[CR] at \f[R]\c
.UR https://github.com/p-j-miller/
.UE \c
\f[CR] \f[R]
.RE
.PP
\f[CR]systime\f[R]\f[CR](\f[R]\f[CR])\f[R]\f[CR] \f[R]\f[CR]	\f[R]\f[CR]	\f[R]\f[CR]Wmawk2 extension. \f[R]\f[CR]Returns the current time\f[R]\f[CR] (UTC)\f[R]\f[CR] as the\f[R]
.RS
.PP
\f[CR]number of seconds\f[R]\f[CR] \f[R]\f[CR]since \f[R]\f[CR]1970\-01\-0100:00:00 UTC\f[R]\f[CR] (the \[lq]Epoch\[rq]\f[R]\f[CR]).\f[R]\f[CR] This always returns an integer number of seconds. In April 2020 [just over 50 years after 1970\-01\-0100:00:00 UTC] it returned 1586616274.\f[R]
.RE
.PP
\f[CR]systime\f[R]\f[CR](\f[R]\f[CR]expr\f[R]\f[CR])\f[R]\f[CR] \f[R]\f[CR]	\f[R]\f[CR]Wmawk2 extension. If expr evaluates to 0 returns the UTC\f[R]
.RS
.PP
\f[CR]time in seconds \f[R]\f[CR]since\f[R]\f[CR] \f[R]\f[CR]1970\-01\-0100:00:00 UTC \f[R]\f[CR]with a 1us resolution. If expr evaluates to a non\-zero number (1 is recommended for future compatibility), returns local time to 1us resolution. Local time is correctly adjusted for the time zone and daylight savings time.\f[R]
.RE
.RS
.PP
\f[CR]The \f[R]\f[CR]AWK\-library at \f[R]\c
.UR https://github.com/p-j-miller/
.UE \c
\f[CR] contains functions to convert\f[R]\f[CR] the result of \f[R]\f[CR]systime\f[R]\f[CR](\f[R]\f[CR]) into a human readable string (date/time), and to convert a human readable string into a number of seconds since the Epoch.\f[R]\f[CR]  \f[R]
.RE
.RS
.PP
\f[CR]Systime\f[R]\f[CR](\f[R]\f[CR]0) is especially useful for timing the execution of awk scripts as it provides 1us resolution.\f[R]\f[CR]
\f[R]
.RE
.RE
.SS 9. Input and output
There are two output statements, \f[B]print\f[R] and \f[B]printf\f[R].
.TP
print
writes \f[B]$0 ORS\f[R] to standard output.
.TP
print \f[I]expr\f[R]1, \f[I]expr\f[R]2, ..., \f[I]expr\f[R]n
writes \f[I]expr\f[R]1 \f[B]OFS\f[R] \f[I]expr\f[R]2 \f[B]OFS\f[R] ...
\f[I]expr\f[R]n \f[B]ORS\f[R] to standard output.
Numeric expressions are converted to string with \f[B]OFMT\f[R].
.TP
printf \f[I]format, expr\-list\f[R]
duplicates the printf C library function writing to standard output.
The complete ANSI C format specifications are recognized with
conversions %c, %d, %e, %E, %f, %g, %G, %i, %o, %s, %u, %x, %X and %%,
and conversion qualifiers h and l.
.PP
The argument list to print or printf can optionally be enclosed in
parentheses.
Print formats numbers using \f[B]OFMT\f[R] or \[dq]%d\[dq] for exact
integers.
\[dq]%c\[dq] with a numeric argument prints the corresponding 8\-bit
character, with a string argument it prints the first character of the
string.
The output of print and printf can be redirected to a file or command by
appending > \f[I]file\f[R], >> \f[I]file\f[R] or | \f[I]command\f[R] to
the end of the print statement.
Redirection opens \f[I]file\f[R] or \f[I]command\f[R] only once;
subsequent redirections append to the already open stream.
By convention, \f[B]Wmawk2\f[R] associates the filename
\[dq]/dev/stderr\[dq] with stderr which allows print and printf to be
redirected to stderr.
\f[B]Wmawk2\f[R] also associates \[dq]\-\[dq] and \[dq]/dev/stdout\[dq]
with stdin and stdout which allows these streams to be passed to
functions.
.PP
The input function \f[B]getline\f[R] has the following variations.
.TP
getline
reads into \f[B]$0\f[R], updates the fields, \f[B]NF\f[R], \f[B]NR\f[R]
and \f[B]FNR\f[R].
.TP
getline < \f[I]file\f[R]
reads into \f[B]$0\f[R] from \f[I]file\f[R], updates the fields and
\f[B]NF\f[R].
.TP
getline \f[I]var\f[R]
reads the next record into \f[I]var\f[R], updates \f[B]NR\f[R] and
\f[B]FNR\f[R].
.TP
getline \f[I]var\f[R] < \f[I]file\f[R]
reads the next record of \f[I]file\f[R] into \f[I]var\f[R].
.TP
\f[I]command\f[R] | getline
pipes a record from \f[I]command\f[R] into \f[B]$0\f[R] and updates the
fields and \f[B]NF\f[R].
.TP
\f[I]command\f[R] | getline \f[I]var\f[R]
pipes a record from \f[I]command\f[R] into \f[I]var\f[R].
.PP
Getline returns 0 on end\-of\-file, \-1 on error, otherwise 1.
.PP
Commands on the end of pipes are executed by windows.
.PP
The function \f[B]close\f[R](\f[I]expr\f[R]) closes the file or pipe
associated with \f[I]expr\f[R].
Close returns 0 if \f[I]expr\f[R] is an open file, the exit status if
\f[I]expr\f[R] is a piped command, and \-1 otherwise.
Close is used to reread a file or command, make sure the other end of an
output pipe is finished or conserve file resources.
.PP
The function \f[B]fflush\f[R](\f[I]expr\f[R]) flushes the output file or
pipe associated with \f[I]expr\f[R].
Fflush returns 0 if \f[I]expr\f[R] is an open output stream else \-1.
Fflush without an argument flushes stdout.
Fflush with an empty argument (\[dq]\[dq]) flushes all open output.
.PP
The function \f[B]system\f[R](\f[I]expr\f[R]) uses Windows to execute
\f[I]expr\f[R] and returns the exit status of the command
\f[I]expr\f[R].
Changes made to the \f[B]ENVIRON\f[R] array are not passed to commands
executed with \f[B]system\f[R] or pipes.
Before executing the system command all output buffers are flushed.
.SS 10. User defined functions
The syntax for a user defined function is
.IP
.EX

	function name( args ) { statements }
.EE
.PP
The function body can contain a return statement
.IP
.EX

	return opt_expr
.EE
.PP
A return statement is not required.
Function calls may be nested or recursive.
Functions are passed expressions by value and arrays by reference.
Extra arguments serve as local variables and are initialized to
\f[I]null\f[R].
For example, csplit(\f[I]s, A\f[R]) puts each character of \f[I]s\f[R]
into array \f[I]A\f[R] and returns the length of \f[I]s\f[R].
.IP
.EX

	function csplit(s, A,	n, i)
	{
	  n = length(s)
	  for( i = 1 ; i <= n ; i++ ) A[i] = substr(s, i, 1)
	  return n
	}
.EE
.PP
Putting extra space between passed arguments and local variables is
conventional.
Functions can be referenced before they are defined, but the function
name and the \[aq](\[aq] of the arguments must touch to avoid confusion
with concatenation.
.SS 11. Splitting strings, records and files
Awk programs use the same algorithm to split strings into arrays with
split(), and records into fields on \f[B]FS\f[R].
\f[B]Wmawk2\f[R] uses essentially the same algorithm to split files into
records on \f[B]RS\f[R].
.PP
Split(\f[I]expr, A, sep\f[R]) works as follows:
.TP
(1)
If \f[I]sep\f[R] is omitted, it is replaced by \f[B]FS\f[R].
\f[I]Sep\f[R] can be an expression or regular expression.
If it is an expression of non\-string type, it is converted to string.
.TP
(2)
If \f[I]sep\f[R] = \[dq] \[dq] (a single space), then <SPACE> is trimmed
from the front and back of \f[I]expr\f[R], and \f[I]sep\f[R] becomes
<SPACE>.
\f[B]Wmawk2\f[R] defines <SPACE> as the regular expression /[
\[rs]t\[rs]n]+/.
Otherwise \f[I]sep\f[R] is treated as a regular expression, except that
meta\-characters are ignored for a string of length 1, e.g., split(x, A,
\[dq]*\[dq]) and split(x, A, /\[rs]*/) are the same.
.TP
(3)
If \f[I]expr\f[R] is not string, it is converted to string.
If \f[I]expr\f[R] is then the empty string \[dq]\[dq], split() returns 0
and \f[I]A\f[R] is set empty.
Otherwise, all non\-overlapping, non\-null and longest matches of
\f[I]sep\f[R] in \f[I]expr\f[R], separate \f[I]expr\f[R] into fields
which are loaded into \f[I]A\f[R].
The fields are placed in A[1], A[2], ..., A[n] and split() returns n,
the number of fields which is the number of matches plus one.
Data placed in \f[I]A\f[R] that looks numeric is typed number and
string.
.PP
Splitting records into fields works the same except the pieces are
loaded into \f[B]$1\f[R], \f[B]$2\f[R],..., \f[B]$NF\f[R].
If \f[B]$0\f[R] is empty, \f[B]NF\f[R] is set to 0 and all \f[B]$i\f[R]
to \[dq]\[dq].
.PP
\f[B]Wmawk2\f[R] splits files into records by the same algorithm, but
with the slight difference that \f[B]RS\f[R] is really a terminator
instead of a separator.
(\f[B]ORS\f[R] is really a terminator too).
.RS
.PP
E.g., if \f[B]FS\f[R] = \[dq]:+\[dq] and \f[B]$0\f[R] = \[dq]a::b:\[dq]
, then \f[B]NF\f[R] = 3 and \f[B]$1\f[R] = \[dq]a\[dq], \f[B]$2\f[R] =
\[dq]b\[dq] and \f[B]$3\f[R] = \[dq]\[dq], but if \[dq]a::b:\[dq] is the
contents of an input file and \f[B]RS\f[R] = \[dq]:+\[dq], then there
are two records \[dq]a\[dq] and \[dq]b\[dq].
.RE
.PP
\f[B]RS\f[R] = \[dq] \[dq] is not special.
.PP
If \f[B]FS\f[R] = \[dq]\[dq], then \f[B]Wmawk2\f[R] breaks the record
into individual characters, and, similarly,
split(\f[I]s,A,\f[R]\[dq]\[dq]) places the individual characters of
\f[I]s\f[R] into \f[I]A\f[R].
.SS 12. Multi\-line records
Since \f[B]Wmawk2\f[R] interprets \f[B]RS\f[R] as a regular expression,
multi\-line records are easy.
Setting \f[B]RS\f[R] = \[dq]\[rs]n\[rs]n+\[dq], makes one or more blank
lines separate records.
If \f[B]FS\f[R] = \[dq] \[dq] (the default), then single newlines, by
the rules for <SPACE> above, become space and single newlines are field
separators.
.RS
.PP
For example, if a file is \[dq]a b\[rs]nc\[rs]n\[rs]n\[dq], \f[B]RS\f[R]
= \[dq]\[rs]n\[rs]n+\[dq] and \f[B]FS\f[R] = \[dq] \[dq], then there is
one record \[dq]a b\[rs]nc\[dq] with three fields \[dq]a\[dq],
\[dq]b\[dq] and \[dq]c\[dq].
Changing \f[B]FS\f[R] = \[dq]\[rs]n\[dq], gives two fields \[dq]a b\[dq]
and \[dq]c\[dq]; changing \f[B]FS\f[R] = \[dq]\[dq], gives one field
identical to the record.
.RE
.PP
If you want lines with spaces or tabs to be considered blank, set
\f[B]RS\f[R] = \[dq]\[rs]n([ \[rs]t]*\[rs]n)+\[dq].
For compatibility with other awks, setting \f[B]RS\f[R] = \[dq]\[dq] has
the same effect as if blank lines are stripped from the front and back
of files and then records are determined as if \f[B]RS\f[R] =
\[dq]\[rs]n\[rs]n+\[dq].
Posix requires that \[dq]\[rs]n\[dq] always separates records when
\f[B]RS\f[R] = \[dq]\[dq] regardless of the value of \f[B]FS\f[R].
\f[B]Wmawk2\f[R] does not support this convention, because defining
\[dq]\[rs]n\[dq] as <SPACE> makes it unnecessary.
.PP
Most of the time when you change \f[B]RS\f[R] for multi\-line records,
you will also want to change \f[B]ORS\f[R] to \[dq]\[rs]n\[rs]n\[dq] so
the record spacing is preserved on output.
.SS 13. Program execution
This section describes the order of program execution.
First \f[B]ARGC\f[R] is set to the total number of command line
arguments passed to the execution phase of the program.
\f[B]ARGV[0]\f[R] is set the name of the AWK interpreter and
\f[B]ARGV[1]\f[R] ...
\f[B]ARGV[ARGC\-1]\f[R] holds the remaining command line arguments
exclusive of options and program source.
For example, with
.IP
.EX

	Wmawk2  \-f  prog  v=1  A  t=hello  B
.EE
.PP
\f[B]ARGC\f[R] = 5 with \f[B]ARGV[0]\f[R] = \[dq]Wmawk2\[dq],
\f[B]ARGV[1]\f[R] = \[dq]v=1\[dq], \f[B]ARGV[2]\f[R] = \[dq]A\[dq],
\f[B]ARGV[3]\f[R] = \[dq]t=hello\[dq] and \f[B]ARGV[4]\f[R] =
\[dq]B\[dq].
.PP
Next, each \f[B]BEGIN\f[R] block is executed in order.
If the program consists entirely of \f[B]BEGIN\f[R] blocks, then
execution terminates, else an input stream is opened and execution
continues.
If \f[B]ARGC\f[R] equals 1, the input stream is set to stdin, else the
command line arguments \f[B]ARGV[1]...\f[R] \f[B]ARGV[ARGC\-1]\f[R] are
examined for a file argument.
.PP
The command line arguments divide into three sets: file arguments,
assignment arguments and empty strings \[dq]\[dq].
An assignment has the form \f[I]var\f[R]=\f[I]string\f[R].
When an \f[B]ARGV[i]\f[R] is examined as a possible file argument, if it
is empty it is skipped; if it is an assignment argument, the assignment
to \f[I]var\f[R] takes place and \f[B]i\f[R] skips to the next argument;
else \f[B]ARGV[i]\f[R] is opened for input.
If it fails to open, execution terminates with exit code 2.
If no command line argument is a file argument, then input comes from
stdin.
Getline in a \f[B]BEGIN\f[R] action opens input.
\[dq]\-\[dq] as a file argument denotes stdin.
.PP
Once an input stream is open, each input record is tested against each
\f[I]pattern\f[R], and if it matches, the associated \f[I]action\f[R] is
executed.
An expression pattern matches if it is boolean true (see the end of
section 2).
A \f[B]BEGIN\f[R] pattern matches before any input has been read, and an
\f[B]END\f[R] pattern matches after all input has been read.
A range pattern, \f[I]expr\f[R]1, \f[I]expr\f[R]2 , matches every record
between the match of \f[I]expr\f[R]1 and the match \f[I]expr\f[R]2
inclusively.
.PP
When end of file occurs on the input stream, the remaining command line
arguments are examined for a file argument, and if there is one it is
opened, else the \f[B]END\f[R] \f[I]pattern\f[R] is considered matched
and all \f[B]END\f[R] \f[I]actions\f[R] are executed.
.PP
In the example, the assignment v=1 takes place after the \f[B]BEGIN\f[R]
\f[I]actions\f[R] are executed, and the data placed in v is typed number
and string.
Input is then read from file A. On end of file A, t is set to the string
\[dq]hello\[dq], and B is opened for input.
On end of file B, the \f[B]END\f[R] \f[I]actions\f[R] are executed.
.PP
Program flow at the \f[I]pattern\f[R] \f[I]{action}\f[R] level can be
changed with the
.IP
.EX

	next
	exit  opt_expr
.EE
.PP
statements.
A \f[B]next\f[R] statement causes the next input record to be read and
pattern testing to restart with the first \f[I]pattern {action}\f[R]
pair in the program.
An \f[B]exit\f[R] statement causes immediate execution of the
\f[B]END\f[R] actions or program termination if there are none or if the
\f[B]exit\f[R] occurs in an \f[B]END\f[R] action.
The \f[I]opt_expr\f[R] sets the exit value of the program unless
overridden by a later \f[B]exit\f[R] or subsequent error.
.PP
The nextfile statement causes wmawk2 to process stop processing the
current file and to start processing the next file specified on the
command line.
This means that FILENAME is changed, FNR is reset to 1 and processing
starts over with the first rule in the program.
.SS 14. Unicode Support
Version 1.2 of Wmawk2 adds utf\-8 functionality (\[rq] Unicode\[rq]) for
the command line, environment variables, filenames and system/pipe
commands and allows the console output to display uft8 characters, and
utf8 characters to be input from the console via stdin.
It does not change any of the string handling or matching functions [
including regular expressions] (which still assume 8\-bit characters),
so for example:
.PP
wmawk2 \[dq]BEGIN{print length(\[rs]\[dq]€\[rs]\[dq])}\[dq]
.PP
will print 3 as the \[oq]€\[cq] (Euro) character takes up 3 bytes when
encoded in utf8.
.PP
Another change in version 1.2 is that
.PP
wmawk2 \[dq]BEGIN {print \[rs]\[dq]€\[rs]\[dq]}\[dq]
.PP
will (correctly) print
.PP
€
.PP
Whereas previous versions of wmawk2 would print:
.PP
wmawk2: write error to file /dev/stdout (Invalid argument)
.PP
The AWK\-library at \c
.UR https://github.com/p-j-miller/
.UE \c
\ provides awk functions that can be used to determine the width of
UTF\-8 characters (in bytes), the number of utf8 characters in a string,
etc.
.PP
In many cases scripts will do what is expected when utf8 Unicode
characters are used, but you do need to remember that what appears to be
a single utf8 character may take multiple bytes.
As a simple example:
.PP
wmawk2 \[dq]$1==\[rs]\[dq]€\[rs]\[dq] {print $1}\[dq]
.PP
does work as expected, as does:
.PP
wmawk2 \[dq]/\[ha][0\-9]+€/ {print }\[dq]
.PP
but:
.PP
wmawk2 \[dq]/\[ha]€+1/ {print }\[dq]
.PP
does not work as expected, for example €€1 will not be matched by the
regex and so not printed (as the € uft8 character needs more than 1 byte
to represent it).
This example is easily fixed as:
.PP
wmawk2 \[dq]/\[ha](€)+1/ {print }\[dq]
.PP
does work as expected.
.PP
Note that uft8 files may start with a BOM (or a BOM mark may need adding
to a uft8 file to allow it to be recognized correctly by other software)
\[en] see \c
.UR https://en.wikipedia.org/wiki/Byte_order_mark
.UE \c
\ for more information.
.PP
Note that you cannot use utf8 characters in awk variable, array or
function names.
.SH EXAMPLES
.IP
.EX
1. emulate cat (echo every line)

	{ print }

2. emulate wc (count the number of words and characters in a file)

	{ chars += length($0) + 1  # add one for the \[rs]n
	  words += NF
	}

	END{ print NR, words, chars }

3. count the number of unique \[dq]real words\[dq].

	BEGIN { FS = \[dq][\[ha]A\-Za\-z]+\[dq] }

	{ for(i = 1 ; i <= NF ; i++)  word[$i] = \[dq]\[dq] }

	END { delete word[\[dq]\[dq]]
	      for ( i in word )  cnt++
	      print cnt
	}
.EE
.PP
4.
sum the second field of every record based on the first field.
.IP
.EX

	$1 \[ti] /credit | gain/ { sum += $2 }
	$1 \[ti] /debit | loss/  { sum \-= $2 }

	END { print sum }


5. sort a file, comparing as string \[en] warning this can be very slow for large files.

	{ line[NR] = $0 \[dq]\[dq] }  # make sure of comparison type
			      # in case some lines look numeric

	END {  isort(line, NR)
	  for(i = 1 ; i <= NR ; i++) print line[i]
	}

	#insertion sort of A[1..n]
	function isort( A, n,	i, j, hold)
	{
	  for( i = 2 ; i <= n ; i++)
	  {
	    hold = A[j = i]
	    while ( A[j\-1] > hold )
	    { j\- \- ; A[j+1] = A[j] }
	    A[j] = hold
	  }
	  # sentinel A[0] = \[dq]\[dq] will be created if needed
	}

The AWK\-library at https://github.com/p\-j\-miller/  provides awk functions for very fast sorting, median calculation, and conversion between strings and times as seconds since the EPOCH (as returned by systime()). Note that multiple files can be loaded using multiple \-f options to wmawk2, so for example:
.EE
.RS
.IP
.EX
wmawk2 \-f median.awk \-f qsort.awk \-f median_test.awk
.EE
.RE
.IP
.EX
Loads the (library) files median.awk and qsort.awk and then loads and executes the program median_test.awk .
.EE
.SH WHY USE AWK/MAWK/WMAWK ?
In general, awk is best at processing largeish text files that can be
basically processed a line at a time, it has no graphics support and
it\[cq]s a command line tool so it has no gui.
.PP
A good example is given at \c
.UR https://brenocon.com/blog/2009/09/dont-mawk-awk-the-fastest-and-most-elegant-big-data-munging-language/
.UE \c
\ .
This example shows that mawk was both the fastest to execute (vs a range
of other languages as well as other awk implementations) and it only
tool 3 lines of awk to implement so was probably the fastest to write as
well.
.PP
If you want more information on awk in general then \c
.UR http://www.awklang.org/
.UE \c
\ is a good place to start.
.SH COMPATIBILITY ISSUES
The Posix 1003.2(draft 11.3) definition of the AWK language is AWK as
described in the AWK book with a few extensions that appeared in
SystemVR4 nawk.
The extensions are:
.RS
.PP
New functions: toupper() and tolower().
.PP
New variables: ENVIRON[ ] and CONVFMT.
.PP
ANSI C conversion specifications for printf() and sprintf().
.PP
New command options: \-v var=value, multiple \-f options and
implementation options as arguments to \-W.
.RE
.PP
\f[B]Wmawk2\f[R] uses its own implementation of printf() and sprint() so
the functionality is fixed independent of the functionality in the
underlying C library functions.
This means that the Null character (\[rs]0) is allowed in the format
string and argument strings.
It also means that %d displays the number as a 64\-bit integer.
The capabilities are print a character, %c; print a signed integer, %d
or %i ; print an unsigned integer, %u, %x, %X or %o; print a
floating\-point number, %f, %g, %G, %e or %E ; print a string, %s.
An optional preceding l is allowed before an integer control character
(which is ignored).
An optional field width and precision as supported as usual.
The porter has tried to ensure the output is identical to that obtained
using gawk when run under Windows but that cannot be guaranteed for all
versions of gawk and all scripts/datasets.
\f[B]Wmawk2\f[R] also uses its own version of strtod() to convert
floating point numbers but this should not impact the underlying
functionality (this was done for speed rather than function).
It should be noted that \f[B]Wmawk2\f[R] does not recognize inf, nan or
hex string as numbers.
This means the data
.PP
0x4 inf nan
.PP
Passed to the script
.PP
{ print 7 + $1, 8 + $2, 9+$3}
.PP
Will result in
.PP
7 8 9
.PP
I.e., the 0x4 inf and nan are all treated as 0 when used as numbers.
This was done for backwards compatibility with earlier versions of awk.
.PP
Note that \f[B]Wmawk2\f[R] uses double precision floating point numbers
(as defined in IEE 754) internally where required.
These provide 15 to 17 significant digits (53 binary bits), have a
maximum value of +/\- 1.797e+308 and a smallest non\-zero number of
+/\-4.94e\-324.
As there are only 53 binary bits available in the mantissa, while
integers are printed by sprintf and printf to 64 bits not all of these
may be exact.
.PP
Posix AWK is oriented to operate on files a line at a time.
\f[B]RS\f[R] can be changed from \[dq]\[rs]n\[dq] to another single
character, but it is hard to find any use for this \[em] there are no
examples in the AWK book.
By convention, \f[B]RS\f[R] = \[dq]\[dq], makes one or more blank lines
separate records, allowing multi\-line records.
When \f[B]RS\f[R] = \[dq]\[dq], \[dq]\[rs]n\[dq] is always a field
separator regardless of the value in \f[B]FS\f[R].
.PP
\f[B]Wmawk2\f[R], on the other hand, allows \f[B]RS\f[R] to be a regular
expression.
When \[dq]\[rs]n\[dq] appears in records, it is treated as space, and
\f[B]FS\f[R] always determines fields.
.PP
Removing the line at a time paradigm can make some programs simpler and
can often improve performance.
For example, redoing example 3 from above,
.IP
.EX

	BEGIN { RS = \[dq][\[ha]A\-Za\-z]+\[dq] }

	{ word[ $0 ] = \[dq]\[dq] }

	END { delete  word[ \[dq]\[dq] ]
	  for( i in word )  cnt++
	  print cnt
	}
.EE
.PP
counts the number of unique words by making each word a record.
On moderate size files, \f[B]Wmawk2\f[R] executes twice as fast, because
of the simplified inner loop.
.PP
The following program replaces each comment by a single space in a C
program file,
.IP
.EX

	BEGIN {
	  RS = \[dq]/ \[rs]*([\[ha]*] | \[rs]*+[\[ha]/*])*\[rs]*+/\[dq]
		# comment is record separator
	  ORS = \[dq] \[dq]
	  getline  hold
       }

       { print hold ; hold = $0 }

       END { printf \[dq]%s\[dq] , hold }
.EE
.PP
Buffering one record is needed to avoid terminating the last record with
a space.
.PP
With \f[B]Wmawk2\f[R], the following are all equivalent,
.IP
.EX

	x \[ti] /a\[rs]+b/    x \[ti] \[dq]a\[rs]+b\[dq]     x \[ti] \[dq]a\[rs]\[rs]+b\[dq]
.EE
.PP
The strings get scanned twice, once as string and once as regular
expression.
On the string scan, \f[B]Wmawk2\f[R] ignores the escape on non\-escape
characters while the AWK book advocates \f[I]\[rs]c\f[R] be recognized
as \f[I]c\f[R] which necessitates the double escaping of
meta\-characters in strings.
Posix explicitly declines to define the behavior which passively forces
programs that must run under a variety of awks to use the more portable
but less readable, double escape.
.PP
Posix AWK does not recognize \[dq]/dev/std{out,err}\[dq] or \[rs]x hex
escape sequences in strings.
Unlike ANSI C, \f[B]Wmawk2\f[R] limits the number of digits that follows
\[rs]x to two as the current implementation only supports 8\-bit
characters.
The built\-in \f[B]fflush\f[R] first appeared in a recent (1993) AT&T
awk released to netlib, and is not part of the posix standard.
Aggregate deletion with \f[B]delete\f[R] \f[I]array\f[R] is not part of
the posix standard.
.PP
Posix explicitly leaves the behavior of \f[B]FS\f[R] = \[dq]\[dq]
undefined, and mentions splitting the record into characters as a
possible interpretation, but currently this use is not portable across
implementations.
.PP
Finally, here is how \f[B]Wmawk2\f[R] handles exceptional cases not
discussed in the AWK book or the Posix draft.
It is unsafe to assume consistency across awks and safe to skip to the
next section.
.RS
.PP
substr(s, i, n) returns the characters of s in the intersection of the
closed interval [1, length(s)] and the half\-open interval [i, i+n).
When this intersection is empty, the empty string is returned; so
substr(\[dq]ABC\[dq], 1, 0) = \[dq]\[dq] and substr(\[dq]ABC\[dq], \-4,
6) = \[dq]A\[dq].
.PP
Every string, including the empty string, matches the empty string at
the front so, s \[ti] // and s \[ti] \[dq]\[dq], are always 1 as is
match(s, //) and match(s, \[dq]\[dq]).
The last two set \f[B]RLENGTH\f[R] to 0.
.PP
index(s, t) is always the same as match(s, t1) where t1 is the same as t
with metacharacters escaped.
Hence consistency with match requires that index(s, \[dq]\[dq]) always
returns 1.
Also the condition, index(s,t) != 0 if and only t is a substring of s,
requires index(\[dq]\[dq],\[dq]\[dq]) = 1.
.PP
If getline encounters end of file, getline var, leaves var unchanged.
Similarly, on entry to the \f[B]END\f[R] actions, \f[B]$0\f[R], the
fields and \f[B]NF\f[R] have their value unaltered from the last record.
.RE
.PP
Note that gawk has a number of extensions that are not present in
mawk/Wmawk2.
In general, these are easy to work around with awk scripts.
As an example, sorting can be done with the functions in the qsort.awk
program in the examples directory, the script at \c
.UR https://docstore.mik.ua/orelly/unix3/sedawk/ch09_03.htm
.UE \c
\ or you can use the sort program at \c
.UR https://github.com/p-j-miller/nsort
.UE \c
\ either via pipes or by using the awk system command.
The AWK\-library at \c
.UR https://github.com/p-j-miller/
.UE \c
\ provides awk functions for very fast sorting, median calculation, and
conversion between strings and times as seconds since the EPOCH (as
returned by systime()).
.SH SEE ALSO
\f[I]Egrep\f[R] (UNIX/Linux command)
.PP
Aho, Kernighan and Weinberger, \f[I]The AWK Programming Language\f[R],
Addison\-Wesley Publishing, 1988, (the AWK book), defines the language,
opening with a tutorial and advancing to many interesting programs that
delve into issues of software design and analysis relevant to
programming in any language.
.PP
\f[I]\c
.UR https://dev.to/rrampage/awk---a-useful-little-language-2fhf
.UE \c
\ a useful, but basic introduction to awk.\f[R]
.PP
\f[I]The GAWK Manual\f[R], The Free Software Foundation, 1991, is a
tutorial and language reference that does not attempt the depth of the
AWK book and assumes the reader may be a novice programmer.
The section on AWK arrays is excellent.
It also discusses Posix requirements for AWK.
.PP
\c
.UR http://www.awklang.org/
.UE \c
\ which claims to be the site for things related to the awk language.
This includes links to 5 awk books., tutorials and a number of examples
including one that can be run live on the web site to deal the cards for
poker hands.
.PP
\c
.UR https://github.com/e36freak/awk-libs
.UE \c
\ a library of awk functions including a number of different sorts,
extra functions for math\[cq]s, strings, csv files, etc.
.SH BUGS
\f[B]Wmawk2\f[R] cannot handle ascii NUL \[rs]0 in source (script)
files.
It is allowed in data files, and you can output NUL using printf with %c
or by printing a string containing a NUL character.
.PP
Implementors of the AWK language have shown a consistent lack of
imagination when naming their programs.
.SH INSTALLATION
The executable (for 64\-bit windows) and this manual as a pdf are
available from github at \c
.UR https://github.com/p-j-miller/wmawk2
.UE \c
\ .
The executable is a portable program and may be placed anywhere (even on
removable media).
It is suggested that you place the directory where the executable is on
your PATH (it\[cq]s easy to find instructions on how to do this on the
web for example search \[lq]adding a directory to path windows 10\[rq])
\[en] if this is not done then you need to include the path to the
executable to invoke \f[B]Wmawk2\f[R] if you are not in the same
directory as the executable.
.PP
Alternatively, you can compile from source \[en] a dev\-c++ project file
is provided in the github repository.
.SH AUTHOR
This windows port was created by Peter Miller.
.PP
Mawk was written by Mike Brennan.
.SH LICENSE
\f[B]Wmawk2\f[R] is distributed without warranty under the terms of the
GNU General Public License, version 3, 2007.
.PP
The files atof.*, unicode.* and ya_sprintf are under the MIT license
(see sources code).
.PP
The source code is available from \c
.UR https://github.com/p-j-miller/wmawk2
.UE \c
.SH VERSIONS
Version \f[B]1.0\f[R] was the first public release.
This was compiled with TDM\-GCC 9.2.0, and uses MSVCRT as runtime
library, which is available on all versions of Windows (but may need to
be downloaded separately from Microsoft).
.PP
Version \f[B]1.1\f[R] was compiled using GCC 14.1.0 x64 (using the UCRT
runtime) for Windows.
The UCRT is effectively built into the operating system in Windows 10
and 11 and can be installed on earlier versions of Windows (see \c
.UR https://support.microsoft.com/en-gb/topic/update-for-universal-c-runtime-in-windows-c0514201-7fe6-95a3-b0a5-287930f3560c
.UE \c
\ ).
Some buffer sizes were also optimized for file i/o, and an internal
random number generator is now used which is \[lq]more random\[rq] than
the one used previously.
There was no change in user functionality with 1v1, but the execution
times for test programs may have changed (in some cases becoming
faster).
.PP
Version \f[B]2.0\f[R] was compiled using GCC 14.2.0 x64 (using the UCRT
runtime) for Windows.
This version adds utf\-8 functionality (\[rq] Unicode\[rq]) for the
command line, environment variables, filenames and system/pipe commands
and allows the console output to display uft8 characters, and utf8
characters to be input from the console via stdin.
It does not change any of the string handling or matching functions [
including regular expressions] (which still assume 8\-bit characters).
For more details see the \[lq]Unicode support\[rq] section of this
manual.
Memory allocation was also changed to improve its speed and, in some
conditions, it will use (potentially a lot) less memory, while in other
situations it may use a little more memory than previously.
Hexadecimal constants (staring 0X or 0X) are now allowed in awk scripts.
Systime(0) and systime(1) functions added.
